import{a as getAugmentedNamespace,c as commonjsGlobal}from"./ai-vendor-BvGnMFDU.js";import{W as WebSocket}from"./vendor-DvUgW7zs.js";const scriptRel="modulepreload",assetsURL=function(dep){return"/"+dep},seen={},__vitePreload=function(baseModule,deps,importerUrl){let promise=Promise.resolve();if(deps&&deps.length>0){document.getElementsByTagName("link");const cspNonceMeta=document.querySelector("meta[property=csp-nonce]"),cspNonce=cspNonceMeta?.nonce||cspNonceMeta?.getAttribute("nonce");promise=Promise.allSettled(deps.map(dep=>{if(dep=assetsURL(dep),dep in seen)return;seen[dep]=!0;const isCss=dep.endsWith(".css"),cssSelector=isCss?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${dep}"]${cssSelector}`))return;const link=document.createElement("link");if(link.rel=isCss?"stylesheet":scriptRel,isCss||(link.as="script"),link.crossOrigin="",link.href=dep,cspNonce&&link.setAttribute("nonce",cspNonce),document.head.appendChild(link),isCss)return new Promise((res,rej)=>{link.addEventListener("load",res),link.addEventListener("error",()=>rej(new Error(`Unable to preload CSS for ${dep}`)))})}))}function handlePreloadError(err){const e=new Event("vite:preloadError",{cancelable:!0});if(e.payload=err,window.dispatchEvent(e),!e.defaultPrevented)throw err}return promise.then(res=>{for(const item of res||[])item.status==="rejected"&&handlePreloadError(item.reason);return baseModule().catch(handlePreloadError)})},resolveFetch$3=customFetch=>{let _fetch;return customFetch?_fetch=customFetch:typeof fetch>"u"?_fetch=(...args)=>__vitePreload(async()=>{const{default:fetch2}=await Promise.resolve().then(()=>browser);return{default:fetch2}},void 0).then(({default:fetch2})=>fetch2(...args)):_fetch=fetch,(...args)=>_fetch(...args)};class FunctionsError extends Error{constructor(message,name="FunctionsError",context){super(message),this.name=name,this.context=context}}class FunctionsFetchError extends FunctionsError{constructor(context){super("Failed to send a request to the Edge Function","FunctionsFetchError",context)}}class FunctionsRelayError extends FunctionsError{constructor(context){super("Relay Error invoking the Edge Function","FunctionsRelayError",context)}}class FunctionsHttpError extends FunctionsError{constructor(context){super("Edge Function returned a non-2xx status code","FunctionsHttpError",context)}}var FunctionRegion;(function(FunctionRegion2){FunctionRegion2.Any="any",FunctionRegion2.ApNortheast1="ap-northeast-1",FunctionRegion2.ApNortheast2="ap-northeast-2",FunctionRegion2.ApSouth1="ap-south-1",FunctionRegion2.ApSoutheast1="ap-southeast-1",FunctionRegion2.ApSoutheast2="ap-southeast-2",FunctionRegion2.CaCentral1="ca-central-1",FunctionRegion2.EuCentral1="eu-central-1",FunctionRegion2.EuWest1="eu-west-1",FunctionRegion2.EuWest2="eu-west-2",FunctionRegion2.EuWest3="eu-west-3",FunctionRegion2.SaEast1="sa-east-1",FunctionRegion2.UsEast1="us-east-1",FunctionRegion2.UsWest1="us-west-1",FunctionRegion2.UsWest2="us-west-2"})(FunctionRegion||(FunctionRegion={}));var __awaiter$7=function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator.throw(value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};class FunctionsClient{constructor(url,{headers={},customFetch,region=FunctionRegion.Any}={}){this.url=url,this.headers=headers,this.region=region,this.fetch=resolveFetch$3(customFetch)}setAuth(token){this.headers.Authorization=`Bearer ${token}`}invoke(functionName,options={}){var _a;return __awaiter$7(this,void 0,void 0,function*(){try{const{headers,method,body:functionArgs}=options;let _headers={},{region}=options;region||(region=this.region);const url=new URL(`${this.url}/${functionName}`);region&&region!=="any"&&(_headers["x-region"]=region,url.searchParams.set("forceFunctionRegion",region));let body;functionArgs&&(headers&&!Object.prototype.hasOwnProperty.call(headers,"Content-Type")||!headers)&&(typeof Blob<"u"&&functionArgs instanceof Blob||functionArgs instanceof ArrayBuffer?(_headers["Content-Type"]="application/octet-stream",body=functionArgs):typeof functionArgs=="string"?(_headers["Content-Type"]="text/plain",body=functionArgs):typeof FormData<"u"&&functionArgs instanceof FormData?body=functionArgs:(_headers["Content-Type"]="application/json",body=JSON.stringify(functionArgs)));const response=yield this.fetch(url.toString(),{method:method||"POST",headers:Object.assign(Object.assign(Object.assign({},_headers),this.headers),headers),body}).catch(fetchError=>{throw new FunctionsFetchError(fetchError)}),isRelayError=response.headers.get("x-relay-error");if(isRelayError&&isRelayError==="true")throw new FunctionsRelayError(response);if(!response.ok)throw new FunctionsHttpError(response);let responseType=((_a=response.headers.get("Content-Type"))!==null&&_a!==void 0?_a:"text/plain").split(";")[0].trim(),data;return responseType==="application/json"?data=yield response.json():responseType==="application/octet-stream"?data=yield response.blob():responseType==="text/event-stream"?data=response:responseType==="multipart/form-data"?data=yield response.formData():data=yield response.text(),{data,error:null,response}}catch(error){return{data:null,error,response:error instanceof FunctionsHttpError||error instanceof FunctionsRelayError?error.context:void 0}}})}}var cjs={},PostgrestClient$2={},PostgrestQueryBuilder$2={},PostgrestFilterBuilder$2={},PostgrestTransformBuilder$2={},PostgrestBuilder$2={},getGlobal=function(){if(typeof self<"u")return self;if(typeof window<"u")return window;if(typeof globalThis<"u")return globalThis;throw new Error("unable to locate global object")},globalObject=getGlobal();const fetch$1=globalObject.fetch,nodeFetch=globalObject.fetch.bind(globalObject),Headers$1=globalObject.Headers,Request=globalObject.Request,Response$1=globalObject.Response,browser=Object.freeze(Object.defineProperty({__proto__:null,Headers:Headers$1,Request,Response:Response$1,default:nodeFetch,fetch:fetch$1},Symbol.toStringTag,{value:"Module"})),require$$0=getAugmentedNamespace(browser);var PostgrestError$2={};Object.defineProperty(PostgrestError$2,"__esModule",{value:!0});let PostgrestError$1=class extends Error{constructor(context){super(context.message),this.name="PostgrestError",this.details=context.details,this.hint=context.hint,this.code=context.code}};PostgrestError$2.default=PostgrestError$1;var __importDefault$5=commonjsGlobal&&commonjsGlobal.__importDefault||function(mod){return mod&&mod.__esModule?mod:{default:mod}};Object.defineProperty(PostgrestBuilder$2,"__esModule",{value:!0});const node_fetch_1=__importDefault$5(require$$0),PostgrestError_1$1=__importDefault$5(PostgrestError$2);let PostgrestBuilder$1=class{constructor(builder){this.shouldThrowOnError=!1,this.method=builder.method,this.url=builder.url,this.headers=builder.headers,this.schema=builder.schema,this.body=builder.body,this.shouldThrowOnError=builder.shouldThrowOnError,this.signal=builder.signal,this.isMaybeSingle=builder.isMaybeSingle,builder.fetch?this.fetch=builder.fetch:typeof fetch>"u"?this.fetch=node_fetch_1.default:this.fetch=fetch}throwOnError(){return this.shouldThrowOnError=!0,this}setHeader(name,value){return this.headers=Object.assign({},this.headers),this.headers[name]=value,this}then(onfulfilled,onrejected){this.schema===void 0||(["GET","HEAD"].includes(this.method)?this.headers["Accept-Profile"]=this.schema:this.headers["Content-Profile"]=this.schema),this.method!=="GET"&&this.method!=="HEAD"&&(this.headers["Content-Type"]="application/json");const _fetch=this.fetch;let res=_fetch(this.url.toString(),{method:this.method,headers:this.headers,body:JSON.stringify(this.body),signal:this.signal}).then(async res2=>{var _a,_b,_c;let error=null,data=null,count=null,status=res2.status,statusText=res2.statusText;if(res2.ok){if(this.method!=="HEAD"){const body=await res2.text();body===""||(this.headers.Accept==="text/csv"||this.headers.Accept&&this.headers.Accept.includes("application/vnd.pgrst.plan+text")?data=body:data=JSON.parse(body))}const countHeader=(_a=this.headers.Prefer)===null||_a===void 0?void 0:_a.match(/count=(exact|planned|estimated)/),contentRange=(_b=res2.headers.get("content-range"))===null||_b===void 0?void 0:_b.split("/");countHeader&&contentRange&&contentRange.length>1&&(count=parseInt(contentRange[1])),this.isMaybeSingle&&this.method==="GET"&&Array.isArray(data)&&(data.length>1?(error={code:"PGRST116",details:`Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,hint:null,message:"JSON object requested, multiple (or no) rows returned"},data=null,count=null,status=406,statusText="Not Acceptable"):data.length===1?data=data[0]:data=null)}else{const body=await res2.text();try{error=JSON.parse(body),Array.isArray(error)&&res2.status===404&&(data=[],error=null,status=200,statusText="OK")}catch{res2.status===404&&body===""?(status=204,statusText="No Content"):error={message:body}}if(error&&this.isMaybeSingle&&(!((_c=error?.details)===null||_c===void 0)&&_c.includes("0 rows"))&&(error=null,status=200,statusText="OK"),error&&this.shouldThrowOnError)throw new PostgrestError_1$1.default(error)}return{error,data,count,status,statusText}});return this.shouldThrowOnError||(res=res.catch(fetchError=>{var _a,_b,_c;return{error:{message:`${(_a=fetchError?.name)!==null&&_a!==void 0?_a:"FetchError"}: ${fetchError?.message}`,details:`${(_b=fetchError?.stack)!==null&&_b!==void 0?_b:""}`,hint:"",code:`${(_c=fetchError?.code)!==null&&_c!==void 0?_c:""}`},data:null,count:null,status:0,statusText:""}})),res.then(onfulfilled,onrejected)}returns(){return this}overrideTypes(){return this}};PostgrestBuilder$2.default=PostgrestBuilder$1;var __importDefault$4=commonjsGlobal&&commonjsGlobal.__importDefault||function(mod){return mod&&mod.__esModule?mod:{default:mod}};Object.defineProperty(PostgrestTransformBuilder$2,"__esModule",{value:!0});const PostgrestBuilder_1$1=__importDefault$4(PostgrestBuilder$2);let PostgrestTransformBuilder$1=class extends PostgrestBuilder_1$1.default{select(columns){let quoted=!1;const cleanedColumns=(columns??"*").split("").map(c=>/\s/.test(c)&&!quoted?"":(c==='"'&&(quoted=!quoted),c)).join("");return this.url.searchParams.set("select",cleanedColumns),this.headers.Prefer&&(this.headers.Prefer+=","),this.headers.Prefer+="return=representation",this}order(column,{ascending=!0,nullsFirst,foreignTable,referencedTable=foreignTable}={}){const key=referencedTable?`${referencedTable}.order`:"order",existingOrder=this.url.searchParams.get(key);return this.url.searchParams.set(key,`${existingOrder?`${existingOrder},`:""}${column}.${ascending?"asc":"desc"}${nullsFirst===void 0?"":nullsFirst?".nullsfirst":".nullslast"}`),this}limit(count,{foreignTable,referencedTable=foreignTable}={}){const key=typeof referencedTable>"u"?"limit":`${referencedTable}.limit`;return this.url.searchParams.set(key,`${count}`),this}range(from,to,{foreignTable,referencedTable=foreignTable}={}){const keyOffset=typeof referencedTable>"u"?"offset":`${referencedTable}.offset`,keyLimit=typeof referencedTable>"u"?"limit":`${referencedTable}.limit`;return this.url.searchParams.set(keyOffset,`${from}`),this.url.searchParams.set(keyLimit,`${to-from+1}`),this}abortSignal(signal){return this.signal=signal,this}single(){return this.headers.Accept="application/vnd.pgrst.object+json",this}maybeSingle(){return this.method==="GET"?this.headers.Accept="application/json":this.headers.Accept="application/vnd.pgrst.object+json",this.isMaybeSingle=!0,this}csv(){return this.headers.Accept="text/csv",this}geojson(){return this.headers.Accept="application/geo+json",this}explain({analyze=!1,verbose=!1,settings=!1,buffers=!1,wal=!1,format="text"}={}){var _a;const options=[analyze?"analyze":null,verbose?"verbose":null,settings?"settings":null,buffers?"buffers":null,wal?"wal":null].filter(Boolean).join("|"),forMediatype=(_a=this.headers.Accept)!==null&&_a!==void 0?_a:"application/json";return this.headers.Accept=`application/vnd.pgrst.plan+${format}; for="${forMediatype}"; options=${options};`,format==="json"?this:this}rollback(){var _a;return((_a=this.headers.Prefer)!==null&&_a!==void 0?_a:"").trim().length>0?this.headers.Prefer+=",tx=rollback":this.headers.Prefer="tx=rollback",this}returns(){return this}};PostgrestTransformBuilder$2.default=PostgrestTransformBuilder$1;var __importDefault$3=commonjsGlobal&&commonjsGlobal.__importDefault||function(mod){return mod&&mod.__esModule?mod:{default:mod}};Object.defineProperty(PostgrestFilterBuilder$2,"__esModule",{value:!0});const PostgrestTransformBuilder_1$1=__importDefault$3(PostgrestTransformBuilder$2);let PostgrestFilterBuilder$1=class extends PostgrestTransformBuilder_1$1.default{eq(column,value){return this.url.searchParams.append(column,`eq.${value}`),this}neq(column,value){return this.url.searchParams.append(column,`neq.${value}`),this}gt(column,value){return this.url.searchParams.append(column,`gt.${value}`),this}gte(column,value){return this.url.searchParams.append(column,`gte.${value}`),this}lt(column,value){return this.url.searchParams.append(column,`lt.${value}`),this}lte(column,value){return this.url.searchParams.append(column,`lte.${value}`),this}like(column,pattern){return this.url.searchParams.append(column,`like.${pattern}`),this}likeAllOf(column,patterns){return this.url.searchParams.append(column,`like(all).{${patterns.join(",")}}`),this}likeAnyOf(column,patterns){return this.url.searchParams.append(column,`like(any).{${patterns.join(",")}}`),this}ilike(column,pattern){return this.url.searchParams.append(column,`ilike.${pattern}`),this}ilikeAllOf(column,patterns){return this.url.searchParams.append(column,`ilike(all).{${patterns.join(",")}}`),this}ilikeAnyOf(column,patterns){return this.url.searchParams.append(column,`ilike(any).{${patterns.join(",")}}`),this}is(column,value){return this.url.searchParams.append(column,`is.${value}`),this}in(column,values){const cleanedValues=Array.from(new Set(values)).map(s=>typeof s=="string"&&new RegExp("[,()]").test(s)?`"${s}"`:`${s}`).join(",");return this.url.searchParams.append(column,`in.(${cleanedValues})`),this}contains(column,value){return typeof value=="string"?this.url.searchParams.append(column,`cs.${value}`):Array.isArray(value)?this.url.searchParams.append(column,`cs.{${value.join(",")}}`):this.url.searchParams.append(column,`cs.${JSON.stringify(value)}`),this}containedBy(column,value){return typeof value=="string"?this.url.searchParams.append(column,`cd.${value}`):Array.isArray(value)?this.url.searchParams.append(column,`cd.{${value.join(",")}}`):this.url.searchParams.append(column,`cd.${JSON.stringify(value)}`),this}rangeGt(column,range){return this.url.searchParams.append(column,`sr.${range}`),this}rangeGte(column,range){return this.url.searchParams.append(column,`nxl.${range}`),this}rangeLt(column,range){return this.url.searchParams.append(column,`sl.${range}`),this}rangeLte(column,range){return this.url.searchParams.append(column,`nxr.${range}`),this}rangeAdjacent(column,range){return this.url.searchParams.append(column,`adj.${range}`),this}overlaps(column,value){return typeof value=="string"?this.url.searchParams.append(column,`ov.${value}`):this.url.searchParams.append(column,`ov.{${value.join(",")}}`),this}textSearch(column,query,{config,type}={}){let typePart="";type==="plain"?typePart="pl":type==="phrase"?typePart="ph":type==="websearch"&&(typePart="w");const configPart=config===void 0?"":`(${config})`;return this.url.searchParams.append(column,`${typePart}fts${configPart}.${query}`),this}match(query){return Object.entries(query).forEach(([column,value])=>{this.url.searchParams.append(column,`eq.${value}`)}),this}not(column,operator,value){return this.url.searchParams.append(column,`not.${operator}.${value}`),this}or(filters,{foreignTable,referencedTable=foreignTable}={}){const key=referencedTable?`${referencedTable}.or`:"or";return this.url.searchParams.append(key,`(${filters})`),this}filter(column,operator,value){return this.url.searchParams.append(column,`${operator}.${value}`),this}};PostgrestFilterBuilder$2.default=PostgrestFilterBuilder$1;var __importDefault$2=commonjsGlobal&&commonjsGlobal.__importDefault||function(mod){return mod&&mod.__esModule?mod:{default:mod}};Object.defineProperty(PostgrestQueryBuilder$2,"__esModule",{value:!0});const PostgrestFilterBuilder_1$2=__importDefault$2(PostgrestFilterBuilder$2);let PostgrestQueryBuilder$1=class{constructor(url,{headers={},schema,fetch:fetch2}){this.url=url,this.headers=headers,this.schema=schema,this.fetch=fetch2}select(columns,{head:head2=!1,count}={}){const method=head2?"HEAD":"GET";let quoted=!1;const cleanedColumns=(columns??"*").split("").map(c=>/\s/.test(c)&&!quoted?"":(c==='"'&&(quoted=!quoted),c)).join("");return this.url.searchParams.set("select",cleanedColumns),count&&(this.headers.Prefer=`count=${count}`),new PostgrestFilterBuilder_1$2.default({method,url:this.url,headers:this.headers,schema:this.schema,fetch:this.fetch,allowEmpty:!1})}insert(values,{count,defaultToNull=!0}={}){const method="POST",prefersHeaders=[];if(this.headers.Prefer&&prefersHeaders.push(this.headers.Prefer),count&&prefersHeaders.push(`count=${count}`),defaultToNull||prefersHeaders.push("missing=default"),this.headers.Prefer=prefersHeaders.join(","),Array.isArray(values)){const columns=values.reduce((acc,x)=>acc.concat(Object.keys(x)),[]);if(columns.length>0){const uniqueColumns=[...new Set(columns)].map(column=>`"${column}"`);this.url.searchParams.set("columns",uniqueColumns.join(","))}}return new PostgrestFilterBuilder_1$2.default({method,url:this.url,headers:this.headers,schema:this.schema,body:values,fetch:this.fetch,allowEmpty:!1})}upsert(values,{onConflict,ignoreDuplicates=!1,count,defaultToNull=!0}={}){const method="POST",prefersHeaders=[`resolution=${ignoreDuplicates?"ignore":"merge"}-duplicates`];if(onConflict!==void 0&&this.url.searchParams.set("on_conflict",onConflict),this.headers.Prefer&&prefersHeaders.push(this.headers.Prefer),count&&prefersHeaders.push(`count=${count}`),defaultToNull||prefersHeaders.push("missing=default"),this.headers.Prefer=prefersHeaders.join(","),Array.isArray(values)){const columns=values.reduce((acc,x)=>acc.concat(Object.keys(x)),[]);if(columns.length>0){const uniqueColumns=[...new Set(columns)].map(column=>`"${column}"`);this.url.searchParams.set("columns",uniqueColumns.join(","))}}return new PostgrestFilterBuilder_1$2.default({method,url:this.url,headers:this.headers,schema:this.schema,body:values,fetch:this.fetch,allowEmpty:!1})}update(values,{count}={}){const method="PATCH",prefersHeaders=[];return this.headers.Prefer&&prefersHeaders.push(this.headers.Prefer),count&&prefersHeaders.push(`count=${count}`),this.headers.Prefer=prefersHeaders.join(","),new PostgrestFilterBuilder_1$2.default({method,url:this.url,headers:this.headers,schema:this.schema,body:values,fetch:this.fetch,allowEmpty:!1})}delete({count}={}){const method="DELETE",prefersHeaders=[];return count&&prefersHeaders.push(`count=${count}`),this.headers.Prefer&&prefersHeaders.unshift(this.headers.Prefer),this.headers.Prefer=prefersHeaders.join(","),new PostgrestFilterBuilder_1$2.default({method,url:this.url,headers:this.headers,schema:this.schema,fetch:this.fetch,allowEmpty:!1})}};PostgrestQueryBuilder$2.default=PostgrestQueryBuilder$1;var constants={},version$4={};Object.defineProperty(version$4,"__esModule",{value:!0});version$4.version=void 0;version$4.version="0.0.0-automated";Object.defineProperty(constants,"__esModule",{value:!0});constants.DEFAULT_HEADERS=void 0;const version_1=version$4;constants.DEFAULT_HEADERS={"X-Client-Info":`postgrest-js/${version_1.version}`};var __importDefault$1=commonjsGlobal&&commonjsGlobal.__importDefault||function(mod){return mod&&mod.__esModule?mod:{default:mod}};Object.defineProperty(PostgrestClient$2,"__esModule",{value:!0});const PostgrestQueryBuilder_1$1=__importDefault$1(PostgrestQueryBuilder$2),PostgrestFilterBuilder_1$1=__importDefault$1(PostgrestFilterBuilder$2),constants_1=constants;let PostgrestClient$1=class PostgrestClient{constructor(url,{headers={},schema,fetch:fetch2}={}){this.url=url,this.headers=Object.assign(Object.assign({},constants_1.DEFAULT_HEADERS),headers),this.schemaName=schema,this.fetch=fetch2}from(relation){const url=new URL(`${this.url}/${relation}`);return new PostgrestQueryBuilder_1$1.default(url,{headers:Object.assign({},this.headers),schema:this.schemaName,fetch:this.fetch})}schema(schema){return new PostgrestClient(this.url,{headers:this.headers,schema,fetch:this.fetch})}rpc(fn,args={},{head:head2=!1,get:get2=!1,count}={}){let method;const url=new URL(`${this.url}/rpc/${fn}`);let body;head2||get2?(method=head2?"HEAD":"GET",Object.entries(args).filter(([_,value])=>value!==void 0).map(([name,value])=>[name,Array.isArray(value)?`{${value.join(",")}}`:`${value}`]).forEach(([name,value])=>{url.searchParams.append(name,value)})):(method="POST",body=args);const headers=Object.assign({},this.headers);return count&&(headers.Prefer=`count=${count}`),new PostgrestFilterBuilder_1$1.default({method,url,headers,schema:this.schemaName,body,fetch:this.fetch,allowEmpty:!1})}};PostgrestClient$2.default=PostgrestClient$1;var __importDefault=commonjsGlobal&&commonjsGlobal.__importDefault||function(mod){return mod&&mod.__esModule?mod:{default:mod}};Object.defineProperty(cjs,"__esModule",{value:!0});cjs.PostgrestError=cjs.PostgrestBuilder=cjs.PostgrestTransformBuilder=cjs.PostgrestFilterBuilder=cjs.PostgrestQueryBuilder=cjs.PostgrestClient=void 0;const PostgrestClient_1=__importDefault(PostgrestClient$2);cjs.PostgrestClient=PostgrestClient_1.default;const PostgrestQueryBuilder_1=__importDefault(PostgrestQueryBuilder$2);cjs.PostgrestQueryBuilder=PostgrestQueryBuilder_1.default;const PostgrestFilterBuilder_1=__importDefault(PostgrestFilterBuilder$2);cjs.PostgrestFilterBuilder=PostgrestFilterBuilder_1.default;const PostgrestTransformBuilder_1=__importDefault(PostgrestTransformBuilder$2);cjs.PostgrestTransformBuilder=PostgrestTransformBuilder_1.default;const PostgrestBuilder_1=__importDefault(PostgrestBuilder$2);cjs.PostgrestBuilder=PostgrestBuilder_1.default;const PostgrestError_1=__importDefault(PostgrestError$2);cjs.PostgrestError=PostgrestError_1.default;var _default=cjs.default={PostgrestClient:PostgrestClient_1.default,PostgrestQueryBuilder:PostgrestQueryBuilder_1.default,PostgrestFilterBuilder:PostgrestFilterBuilder_1.default,PostgrestTransformBuilder:PostgrestTransformBuilder_1.default,PostgrestBuilder:PostgrestBuilder_1.default,PostgrestError:PostgrestError_1.default};const{PostgrestClient:PostgrestClient2,PostgrestQueryBuilder:PostgrestQueryBuilder2,PostgrestFilterBuilder:PostgrestFilterBuilder2,PostgrestTransformBuilder:PostgrestTransformBuilder2,PostgrestBuilder:PostgrestBuilder2,PostgrestError:PostgrestError2}=_default,version$3="2.11.15",DEFAULT_VERSION=`realtime-js/${version$3}`,VSN="1.0.0",DEFAULT_TIMEOUT=1e4,WS_CLOSE_NORMAL=1e3;var SOCKET_STATES;(function(SOCKET_STATES2){SOCKET_STATES2[SOCKET_STATES2.connecting=0]="connecting",SOCKET_STATES2[SOCKET_STATES2.open=1]="open",SOCKET_STATES2[SOCKET_STATES2.closing=2]="closing",SOCKET_STATES2[SOCKET_STATES2.closed=3]="closed"})(SOCKET_STATES||(SOCKET_STATES={}));var CHANNEL_STATES;(function(CHANNEL_STATES2){CHANNEL_STATES2.closed="closed",CHANNEL_STATES2.errored="errored",CHANNEL_STATES2.joined="joined",CHANNEL_STATES2.joining="joining",CHANNEL_STATES2.leaving="leaving"})(CHANNEL_STATES||(CHANNEL_STATES={}));var CHANNEL_EVENTS;(function(CHANNEL_EVENTS2){CHANNEL_EVENTS2.close="phx_close",CHANNEL_EVENTS2.error="phx_error",CHANNEL_EVENTS2.join="phx_join",CHANNEL_EVENTS2.reply="phx_reply",CHANNEL_EVENTS2.leave="phx_leave",CHANNEL_EVENTS2.access_token="access_token"})(CHANNEL_EVENTS||(CHANNEL_EVENTS={}));var TRANSPORTS;(function(TRANSPORTS2){TRANSPORTS2.websocket="websocket"})(TRANSPORTS||(TRANSPORTS={}));var CONNECTION_STATE;(function(CONNECTION_STATE2){CONNECTION_STATE2.Connecting="connecting",CONNECTION_STATE2.Open="open",CONNECTION_STATE2.Closing="closing",CONNECTION_STATE2.Closed="closed"})(CONNECTION_STATE||(CONNECTION_STATE={}));class Serializer{constructor(){this.HEADER_LENGTH=1}decode(rawPayload,callback){return rawPayload.constructor===ArrayBuffer?callback(this._binaryDecode(rawPayload)):callback(typeof rawPayload=="string"?JSON.parse(rawPayload):{})}_binaryDecode(buffer){const view=new DataView(buffer),decoder=new TextDecoder;return this._decodeBroadcast(buffer,view,decoder)}_decodeBroadcast(buffer,view,decoder){const topicSize=view.getUint8(1),eventSize=view.getUint8(2);let offset=this.HEADER_LENGTH+2;const topic=decoder.decode(buffer.slice(offset,offset+topicSize));offset=offset+topicSize;const event=decoder.decode(buffer.slice(offset,offset+eventSize));offset=offset+eventSize;const data=JSON.parse(decoder.decode(buffer.slice(offset,buffer.byteLength)));return{ref:null,topic,event,payload:data}}}class Timer{constructor(callback,timerCalc){this.callback=callback,this.timerCalc=timerCalc,this.timer=void 0,this.tries=0,this.callback=callback,this.timerCalc=timerCalc}reset(){this.tries=0,clearTimeout(this.timer)}scheduleTimeout(){clearTimeout(this.timer),this.timer=setTimeout(()=>{this.tries=this.tries+1,this.callback()},this.timerCalc(this.tries+1))}}var PostgresTypes;(function(PostgresTypes2){PostgresTypes2.abstime="abstime",PostgresTypes2.bool="bool",PostgresTypes2.date="date",PostgresTypes2.daterange="daterange",PostgresTypes2.float4="float4",PostgresTypes2.float8="float8",PostgresTypes2.int2="int2",PostgresTypes2.int4="int4",PostgresTypes2.int4range="int4range",PostgresTypes2.int8="int8",PostgresTypes2.int8range="int8range",PostgresTypes2.json="json",PostgresTypes2.jsonb="jsonb",PostgresTypes2.money="money",PostgresTypes2.numeric="numeric",PostgresTypes2.oid="oid",PostgresTypes2.reltime="reltime",PostgresTypes2.text="text",PostgresTypes2.time="time",PostgresTypes2.timestamp="timestamp",PostgresTypes2.timestamptz="timestamptz",PostgresTypes2.timetz="timetz",PostgresTypes2.tsrange="tsrange",PostgresTypes2.tstzrange="tstzrange"})(PostgresTypes||(PostgresTypes={}));const convertChangeData=(columns,record,options={})=>{var _a;const skipTypes=(_a=options.skipTypes)!==null&&_a!==void 0?_a:[];return Object.keys(record).reduce((acc,rec_key)=>(acc[rec_key]=convertColumn(rec_key,columns,record,skipTypes),acc),{})},convertColumn=(columnName,columns,record,skipTypes)=>{const column=columns.find(x=>x.name===columnName),colType=column?.type,value=record[columnName];return colType&&!skipTypes.includes(colType)?convertCell(colType,value):noop$1(value)},convertCell=(type,value)=>{if(type.charAt(0)==="_"){const dataType=type.slice(1,type.length);return toArray(value,dataType)}switch(type){case PostgresTypes.bool:return toBoolean(value);case PostgresTypes.float4:case PostgresTypes.float8:case PostgresTypes.int2:case PostgresTypes.int4:case PostgresTypes.int8:case PostgresTypes.numeric:case PostgresTypes.oid:return toNumber(value);case PostgresTypes.json:case PostgresTypes.jsonb:return toJson(value);case PostgresTypes.timestamp:return toTimestampString(value);case PostgresTypes.abstime:case PostgresTypes.date:case PostgresTypes.daterange:case PostgresTypes.int4range:case PostgresTypes.int8range:case PostgresTypes.money:case PostgresTypes.reltime:case PostgresTypes.text:case PostgresTypes.time:case PostgresTypes.timestamptz:case PostgresTypes.timetz:case PostgresTypes.tsrange:case PostgresTypes.tstzrange:return noop$1(value);default:return noop$1(value)}},noop$1=value=>value,toBoolean=value=>{switch(value){case"t":return!0;case"f":return!1;default:return value}},toNumber=value=>{if(typeof value=="string"){const parsedValue=parseFloat(value);if(!Number.isNaN(parsedValue))return parsedValue}return value},toJson=value=>{if(typeof value=="string")try{return JSON.parse(value)}catch(error){return console.log(`JSON parse error: ${error}`),value}return value},toArray=(value,type)=>{if(typeof value!="string")return value;const lastIdx=value.length-1,closeBrace=value[lastIdx];if(value[0]==="{"&&closeBrace==="}"){let arr;const valTrim=value.slice(1,lastIdx);try{arr=JSON.parse("["+valTrim+"]")}catch{arr=valTrim?valTrim.split(","):[]}return arr.map(val=>convertCell(type,val))}return value},toTimestampString=value=>typeof value=="string"?value.replace(" ","T"):value,httpEndpointURL=socketUrl=>{let url=socketUrl;return url=url.replace(/^ws/i,"http"),url=url.replace(/(\/socket\/websocket|\/socket|\/websocket)\/?$/i,""),url.replace(/\/+$/,"")};class Push{constructor(channel,event,payload={},timeout=DEFAULT_TIMEOUT){this.channel=channel,this.event=event,this.payload=payload,this.timeout=timeout,this.sent=!1,this.timeoutTimer=void 0,this.ref="",this.receivedResp=null,this.recHooks=[],this.refEvent=null}resend(timeout){this.timeout=timeout,this._cancelRefEvent(),this.ref="",this.refEvent=null,this.receivedResp=null,this.sent=!1,this.send()}send(){this._hasReceived("timeout")||(this.startTimeout(),this.sent=!0,this.channel.socket.push({topic:this.channel.topic,event:this.event,payload:this.payload,ref:this.ref,join_ref:this.channel._joinRef()}))}updatePayload(payload){this.payload=Object.assign(Object.assign({},this.payload),payload)}receive(status,callback){var _a;return this._hasReceived(status)&&callback((_a=this.receivedResp)===null||_a===void 0?void 0:_a.response),this.recHooks.push({status,callback}),this}startTimeout(){if(this.timeoutTimer)return;this.ref=this.channel.socket._makeRef(),this.refEvent=this.channel._replyEventName(this.ref);const callback=payload=>{this._cancelRefEvent(),this._cancelTimeout(),this.receivedResp=payload,this._matchReceive(payload)};this.channel._on(this.refEvent,{},callback),this.timeoutTimer=setTimeout(()=>{this.trigger("timeout",{})},this.timeout)}trigger(status,response){this.refEvent&&this.channel._trigger(this.refEvent,{status,response})}destroy(){this._cancelRefEvent(),this._cancelTimeout()}_cancelRefEvent(){this.refEvent&&this.channel._off(this.refEvent,{})}_cancelTimeout(){clearTimeout(this.timeoutTimer),this.timeoutTimer=void 0}_matchReceive({status,response}){this.recHooks.filter(h=>h.status===status).forEach(h=>h.callback(response))}_hasReceived(status){return this.receivedResp&&this.receivedResp.status===status}}var REALTIME_PRESENCE_LISTEN_EVENTS;(function(REALTIME_PRESENCE_LISTEN_EVENTS2){REALTIME_PRESENCE_LISTEN_EVENTS2.SYNC="sync",REALTIME_PRESENCE_LISTEN_EVENTS2.JOIN="join",REALTIME_PRESENCE_LISTEN_EVENTS2.LEAVE="leave"})(REALTIME_PRESENCE_LISTEN_EVENTS||(REALTIME_PRESENCE_LISTEN_EVENTS={}));class RealtimePresence{constructor(channel,opts){this.channel=channel,this.state={},this.pendingDiffs=[],this.joinRef=null,this.caller={onJoin:()=>{},onLeave:()=>{},onSync:()=>{}};const events=opts?.events||{state:"presence_state",diff:"presence_diff"};this.channel._on(events.state,{},newState=>{const{onJoin,onLeave,onSync}=this.caller;this.joinRef=this.channel._joinRef(),this.state=RealtimePresence.syncState(this.state,newState,onJoin,onLeave),this.pendingDiffs.forEach(diff=>{this.state=RealtimePresence.syncDiff(this.state,diff,onJoin,onLeave)}),this.pendingDiffs=[],onSync()}),this.channel._on(events.diff,{},diff=>{const{onJoin,onLeave,onSync}=this.caller;this.inPendingSyncState()?this.pendingDiffs.push(diff):(this.state=RealtimePresence.syncDiff(this.state,diff,onJoin,onLeave),onSync())}),this.onJoin((key,currentPresences,newPresences)=>{this.channel._trigger("presence",{event:"join",key,currentPresences,newPresences})}),this.onLeave((key,currentPresences,leftPresences)=>{this.channel._trigger("presence",{event:"leave",key,currentPresences,leftPresences})}),this.onSync(()=>{this.channel._trigger("presence",{event:"sync"})})}static syncState(currentState,newState,onJoin,onLeave){const state=this.cloneDeep(currentState),transformedState=this.transformState(newState),joins={},leaves={};return this.map(state,(key,presences)=>{transformedState[key]||(leaves[key]=presences)}),this.map(transformedState,(key,newPresences)=>{const currentPresences=state[key];if(currentPresences){const newPresenceRefs=newPresences.map(m=>m.presence_ref),curPresenceRefs=currentPresences.map(m=>m.presence_ref),joinedPresences=newPresences.filter(m=>curPresenceRefs.indexOf(m.presence_ref)<0),leftPresences=currentPresences.filter(m=>newPresenceRefs.indexOf(m.presence_ref)<0);joinedPresences.length>0&&(joins[key]=joinedPresences),leftPresences.length>0&&(leaves[key]=leftPresences)}else joins[key]=newPresences}),this.syncDiff(state,{joins,leaves},onJoin,onLeave)}static syncDiff(state,diff,onJoin,onLeave){const{joins,leaves}={joins:this.transformState(diff.joins),leaves:this.transformState(diff.leaves)};return onJoin||(onJoin=()=>{}),onLeave||(onLeave=()=>{}),this.map(joins,(key,newPresences)=>{var _a;const currentPresences=(_a=state[key])!==null&&_a!==void 0?_a:[];if(state[key]=this.cloneDeep(newPresences),currentPresences.length>0){const joinedPresenceRefs=state[key].map(m=>m.presence_ref),curPresences=currentPresences.filter(m=>joinedPresenceRefs.indexOf(m.presence_ref)<0);state[key].unshift(...curPresences)}onJoin(key,currentPresences,newPresences)}),this.map(leaves,(key,leftPresences)=>{let currentPresences=state[key];if(!currentPresences)return;const presenceRefsToRemove=leftPresences.map(m=>m.presence_ref);currentPresences=currentPresences.filter(m=>presenceRefsToRemove.indexOf(m.presence_ref)<0),state[key]=currentPresences,onLeave(key,currentPresences,leftPresences),currentPresences.length===0&&delete state[key]}),state}static map(obj,func){return Object.getOwnPropertyNames(obj).map(key=>func(key,obj[key]))}static transformState(state){return state=this.cloneDeep(state),Object.getOwnPropertyNames(state).reduce((newState,key)=>{const presences=state[key];return"metas"in presences?newState[key]=presences.metas.map(presence=>(presence.presence_ref=presence.phx_ref,delete presence.phx_ref,delete presence.phx_ref_prev,presence)):newState[key]=presences,newState},{})}static cloneDeep(obj){return JSON.parse(JSON.stringify(obj))}onJoin(callback){this.caller.onJoin=callback}onLeave(callback){this.caller.onLeave=callback}onSync(callback){this.caller.onSync=callback}inPendingSyncState(){return!this.joinRef||this.joinRef!==this.channel._joinRef()}}var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;(function(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2){REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2.ALL="*",REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2.INSERT="INSERT",REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2.UPDATE="UPDATE",REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2.DELETE="DELETE"})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT||(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT={}));var REALTIME_LISTEN_TYPES;(function(REALTIME_LISTEN_TYPES2){REALTIME_LISTEN_TYPES2.BROADCAST="broadcast",REALTIME_LISTEN_TYPES2.PRESENCE="presence",REALTIME_LISTEN_TYPES2.POSTGRES_CHANGES="postgres_changes",REALTIME_LISTEN_TYPES2.SYSTEM="system"})(REALTIME_LISTEN_TYPES||(REALTIME_LISTEN_TYPES={}));var REALTIME_SUBSCRIBE_STATES;(function(REALTIME_SUBSCRIBE_STATES2){REALTIME_SUBSCRIBE_STATES2.SUBSCRIBED="SUBSCRIBED",REALTIME_SUBSCRIBE_STATES2.TIMED_OUT="TIMED_OUT",REALTIME_SUBSCRIBE_STATES2.CLOSED="CLOSED",REALTIME_SUBSCRIBE_STATES2.CHANNEL_ERROR="CHANNEL_ERROR"})(REALTIME_SUBSCRIBE_STATES||(REALTIME_SUBSCRIBE_STATES={}));class RealtimeChannel{constructor(topic,params={config:{}},socket){this.topic=topic,this.params=params,this.socket=socket,this.bindings={},this.state=CHANNEL_STATES.closed,this.joinedOnce=!1,this.pushBuffer=[],this.subTopic=topic.replace(/^realtime:/i,""),this.params.config=Object.assign({broadcast:{ack:!1,self:!1},presence:{key:""},private:!1},params.config),this.timeout=this.socket.timeout,this.joinPush=new Push(this,CHANNEL_EVENTS.join,this.params,this.timeout),this.rejoinTimer=new Timer(()=>this._rejoinUntilConnected(),this.socket.reconnectAfterMs),this.joinPush.receive("ok",()=>{this.state=CHANNEL_STATES.joined,this.rejoinTimer.reset(),this.pushBuffer.forEach(pushEvent=>pushEvent.send()),this.pushBuffer=[]}),this._onClose(()=>{this.rejoinTimer.reset(),this.socket.log("channel",`close ${this.topic} ${this._joinRef()}`),this.state=CHANNEL_STATES.closed,this.socket._remove(this)}),this._onError(reason=>{this._isLeaving()||this._isClosed()||(this.socket.log("channel",`error ${this.topic}`,reason),this.state=CHANNEL_STATES.errored,this.rejoinTimer.scheduleTimeout())}),this.joinPush.receive("timeout",()=>{this._isJoining()&&(this.socket.log("channel",`timeout ${this.topic}`,this.joinPush.timeout),this.state=CHANNEL_STATES.errored,this.rejoinTimer.scheduleTimeout())}),this._on(CHANNEL_EVENTS.reply,{},(payload,ref)=>{this._trigger(this._replyEventName(ref),payload)}),this.presence=new RealtimePresence(this),this.broadcastEndpointURL=httpEndpointURL(this.socket.endPoint)+"/api/broadcast",this.private=this.params.config.private||!1}subscribe(callback,timeout=this.timeout){var _a,_b;if(this.socket.isConnected()||this.socket.connect(),this.state==CHANNEL_STATES.closed){const{config:{broadcast,presence,private:isPrivate}}=this.params;this._onError(e=>callback?.(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR,e)),this._onClose(()=>callback?.(REALTIME_SUBSCRIBE_STATES.CLOSED));const accessTokenPayload={},config={broadcast,presence,postgres_changes:(_b=(_a=this.bindings.postgres_changes)===null||_a===void 0?void 0:_a.map(r=>r.filter))!==null&&_b!==void 0?_b:[],private:isPrivate};this.socket.accessTokenValue&&(accessTokenPayload.access_token=this.socket.accessTokenValue),this.updateJoinPayload(Object.assign({config},accessTokenPayload)),this.joinedOnce=!0,this._rejoin(timeout),this.joinPush.receive("ok",async({postgres_changes})=>{var _a2;if(this.socket.setAuth(),postgres_changes===void 0){callback?.(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);return}else{const clientPostgresBindings=this.bindings.postgres_changes,bindingsLen=(_a2=clientPostgresBindings?.length)!==null&&_a2!==void 0?_a2:0,newPostgresBindings=[];for(let i=0;i<bindingsLen;i++){const clientPostgresBinding=clientPostgresBindings[i],{filter:{event,schema,table,filter}}=clientPostgresBinding,serverPostgresFilter=postgres_changes&&postgres_changes[i];if(serverPostgresFilter&&serverPostgresFilter.event===event&&serverPostgresFilter.schema===schema&&serverPostgresFilter.table===table&&serverPostgresFilter.filter===filter)newPostgresBindings.push(Object.assign(Object.assign({},clientPostgresBinding),{id:serverPostgresFilter.id}));else{this.unsubscribe(),this.state=CHANNEL_STATES.errored,callback?.(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR,new Error("mismatch between server and client bindings for postgres changes"));return}}this.bindings.postgres_changes=newPostgresBindings,callback&&callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);return}}).receive("error",error=>{this.state=CHANNEL_STATES.errored,callback?.(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR,new Error(JSON.stringify(Object.values(error).join(", ")||"error")))}).receive("timeout",()=>{callback?.(REALTIME_SUBSCRIBE_STATES.TIMED_OUT)})}return this}presenceState(){return this.presence.state}async track(payload,opts={}){return await this.send({type:"presence",event:"track",payload},opts.timeout||this.timeout)}async untrack(opts={}){return await this.send({type:"presence",event:"untrack"},opts)}on(type,filter,callback){return this._on(type,filter,callback)}async send(args,opts={}){var _a,_b;if(!this._canPush()&&args.type==="broadcast"){const{event,payload:endpoint_payload}=args,options={method:"POST",headers:{Authorization:this.socket.accessTokenValue?`Bearer ${this.socket.accessTokenValue}`:"",apikey:this.socket.apiKey?this.socket.apiKey:"","Content-Type":"application/json"},body:JSON.stringify({messages:[{topic:this.subTopic,event,payload:endpoint_payload,private:this.private}]})};try{const response=await this._fetchWithTimeout(this.broadcastEndpointURL,options,(_a=opts.timeout)!==null&&_a!==void 0?_a:this.timeout);return await((_b=response.body)===null||_b===void 0?void 0:_b.cancel()),response.ok?"ok":"error"}catch(error){return error.name==="AbortError"?"timed out":"error"}}else return new Promise(resolve=>{var _a2,_b2,_c;const push=this._push(args.type,args,opts.timeout||this.timeout);args.type==="broadcast"&&!(!((_c=(_b2=(_a2=this.params)===null||_a2===void 0?void 0:_a2.config)===null||_b2===void 0?void 0:_b2.broadcast)===null||_c===void 0)&&_c.ack)&&resolve("ok"),push.receive("ok",()=>resolve("ok")),push.receive("error",()=>resolve("error")),push.receive("timeout",()=>resolve("timed out"))})}updateJoinPayload(payload){this.joinPush.updatePayload(payload)}unsubscribe(timeout=this.timeout){this.state=CHANNEL_STATES.leaving;const onClose=()=>{this.socket.log("channel",`leave ${this.topic}`),this._trigger(CHANNEL_EVENTS.close,"leave",this._joinRef())};this.joinPush.destroy();let leavePush=null;return new Promise(resolve=>{leavePush=new Push(this,CHANNEL_EVENTS.leave,{},timeout),leavePush.receive("ok",()=>{onClose(),resolve("ok")}).receive("timeout",()=>{onClose(),resolve("timed out")}).receive("error",()=>{resolve("error")}),leavePush.send(),this._canPush()||leavePush.trigger("ok",{})}).finally(()=>{leavePush?.destroy()})}teardown(){this.pushBuffer.forEach(push=>push.destroy()),this.rejoinTimer&&clearTimeout(this.rejoinTimer.timer),this.joinPush.destroy()}async _fetchWithTimeout(url,options,timeout){const controller=new AbortController,id=setTimeout(()=>controller.abort(),timeout),response=await this.socket.fetch(url,Object.assign(Object.assign({},options),{signal:controller.signal}));return clearTimeout(id),response}_push(event,payload,timeout=this.timeout){if(!this.joinedOnce)throw`tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;let pushEvent=new Push(this,event,payload,timeout);return this._canPush()?pushEvent.send():(pushEvent.startTimeout(),this.pushBuffer.push(pushEvent)),pushEvent}_onMessage(_event,payload,_ref){return payload}_isMember(topic){return this.topic===topic}_joinRef(){return this.joinPush.ref}_trigger(type,payload,ref){var _a,_b;const typeLower=type.toLocaleLowerCase(),{close,error,leave,join}=CHANNEL_EVENTS;if(ref&&[close,error,leave,join].indexOf(typeLower)>=0&&ref!==this._joinRef())return;let handledPayload=this._onMessage(typeLower,payload,ref);if(payload&&!handledPayload)throw"channel onMessage callbacks must return the payload, modified or unmodified";["insert","update","delete"].includes(typeLower)?(_a=this.bindings.postgres_changes)===null||_a===void 0||_a.filter(bind=>{var _a2,_b2,_c;return((_a2=bind.filter)===null||_a2===void 0?void 0:_a2.event)==="*"||((_c=(_b2=bind.filter)===null||_b2===void 0?void 0:_b2.event)===null||_c===void 0?void 0:_c.toLocaleLowerCase())===typeLower}).map(bind=>bind.callback(handledPayload,ref)):(_b=this.bindings[typeLower])===null||_b===void 0||_b.filter(bind=>{var _a2,_b2,_c,_d,_e,_f;if(["broadcast","presence","postgres_changes"].includes(typeLower))if("id"in bind){const bindId=bind.id,bindEvent=(_a2=bind.filter)===null||_a2===void 0?void 0:_a2.event;return bindId&&((_b2=payload.ids)===null||_b2===void 0?void 0:_b2.includes(bindId))&&(bindEvent==="*"||bindEvent?.toLocaleLowerCase()===((_c=payload.data)===null||_c===void 0?void 0:_c.type.toLocaleLowerCase()))}else{const bindEvent=(_e=(_d=bind?.filter)===null||_d===void 0?void 0:_d.event)===null||_e===void 0?void 0:_e.toLocaleLowerCase();return bindEvent==="*"||bindEvent===((_f=payload?.event)===null||_f===void 0?void 0:_f.toLocaleLowerCase())}else return bind.type.toLocaleLowerCase()===typeLower}).map(bind=>{if(typeof handledPayload=="object"&&"ids"in handledPayload){const postgresChanges=handledPayload.data,{schema,table,commit_timestamp,type:type2,errors}=postgresChanges;handledPayload=Object.assign(Object.assign({},{schema,table,commit_timestamp,eventType:type2,new:{},old:{},errors}),this._getPayloadRecords(postgresChanges))}bind.callback(handledPayload,ref)})}_isClosed(){return this.state===CHANNEL_STATES.closed}_isJoined(){return this.state===CHANNEL_STATES.joined}_isJoining(){return this.state===CHANNEL_STATES.joining}_isLeaving(){return this.state===CHANNEL_STATES.leaving}_replyEventName(ref){return`chan_reply_${ref}`}_on(type,filter,callback){const typeLower=type.toLocaleLowerCase(),binding={type:typeLower,filter,callback};return this.bindings[typeLower]?this.bindings[typeLower].push(binding):this.bindings[typeLower]=[binding],this}_off(type,filter){const typeLower=type.toLocaleLowerCase();return this.bindings[typeLower]=this.bindings[typeLower].filter(bind=>{var _a;return!(((_a=bind.type)===null||_a===void 0?void 0:_a.toLocaleLowerCase())===typeLower&&RealtimeChannel.isEqual(bind.filter,filter))}),this}static isEqual(obj1,obj2){if(Object.keys(obj1).length!==Object.keys(obj2).length)return!1;for(const k in obj1)if(obj1[k]!==obj2[k])return!1;return!0}_rejoinUntilConnected(){this.rejoinTimer.scheduleTimeout(),this.socket.isConnected()&&this._rejoin()}_onClose(callback){this._on(CHANNEL_EVENTS.close,{},callback)}_onError(callback){this._on(CHANNEL_EVENTS.error,{},reason=>callback(reason))}_canPush(){return this.socket.isConnected()&&this._isJoined()}_rejoin(timeout=this.timeout){this._isLeaving()||(this.socket._leaveOpenTopic(this.topic),this.state=CHANNEL_STATES.joining,this.joinPush.resend(timeout))}_getPayloadRecords(payload){const records={new:{},old:{}};return(payload.type==="INSERT"||payload.type==="UPDATE")&&(records.new=convertChangeData(payload.columns,payload.record)),(payload.type==="UPDATE"||payload.type==="DELETE")&&(records.old=convertChangeData(payload.columns,payload.old_record)),records}}const noop=()=>{},WORKER_SCRIPT=`
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;class RealtimeClient{constructor(endPoint,options){var _a;this.accessTokenValue=null,this.apiKey=null,this.channels=new Array,this.endPoint="",this.httpEndpoint="",this.headers={},this.params={},this.timeout=DEFAULT_TIMEOUT,this.heartbeatIntervalMs=25e3,this.heartbeatTimer=void 0,this.pendingHeartbeatRef=null,this.heartbeatCallback=noop,this.ref=0,this.logger=noop,this.conn=null,this.sendBuffer=[],this.serializer=new Serializer,this.stateChangeCallbacks={open:[],close:[],error:[],message:[]},this.accessToken=null,this._resolveFetch=customFetch=>{let _fetch;return customFetch?_fetch=customFetch:typeof fetch>"u"?_fetch=(...args)=>__vitePreload(async()=>{const{default:fetch2}=await Promise.resolve().then(()=>browser);return{default:fetch2}},void 0).then(({default:fetch2})=>fetch2(...args)):_fetch=fetch,(...args)=>_fetch(...args)},this.endPoint=`${endPoint}/${TRANSPORTS.websocket}`,this.httpEndpoint=httpEndpointURL(endPoint),options?.transport?this.transport=options.transport:this.transport=null,options?.params&&(this.params=options.params),options?.timeout&&(this.timeout=options.timeout),options?.logger&&(this.logger=options.logger),(options?.logLevel||options?.log_level)&&(this.logLevel=options.logLevel||options.log_level,this.params=Object.assign(Object.assign({},this.params),{log_level:this.logLevel})),options?.heartbeatIntervalMs&&(this.heartbeatIntervalMs=options.heartbeatIntervalMs);const accessTokenValue=(_a=options?.params)===null||_a===void 0?void 0:_a.apikey;if(accessTokenValue&&(this.accessTokenValue=accessTokenValue,this.apiKey=accessTokenValue),this.reconnectAfterMs=options?.reconnectAfterMs?options.reconnectAfterMs:tries=>[1e3,2e3,5e3,1e4][tries-1]||1e4,this.encode=options?.encode?options.encode:(payload,callback)=>callback(JSON.stringify(payload)),this.decode=options?.decode?options.decode:this.serializer.decode.bind(this.serializer),this.reconnectTimer=new Timer(async()=>{this.disconnect(),this.connect()},this.reconnectAfterMs),this.fetch=this._resolveFetch(options?.fetch),options?.worker){if(typeof window<"u"&&!window.Worker)throw new Error("Web Worker is not supported");this.worker=options?.worker||!1,this.workerUrl=options?.workerUrl}this.accessToken=options?.accessToken||null}connect(){if(!this.conn){if(this.transport||(this.transport=WebSocket),!this.transport)throw new Error("No transport provided");this.conn=new this.transport(this.endpointURL()),this.setupConnection()}}endpointURL(){return this._appendParams(this.endPoint,Object.assign({},this.params,{vsn:VSN}))}disconnect(code,reason){this.conn&&(this.conn.onclose=function(){},code?this.conn.close(code,reason??""):this.conn.close(),this.conn=null,this.heartbeatTimer&&clearInterval(this.heartbeatTimer),this.reconnectTimer.reset(),this.channels.forEach(channel=>channel.teardown()))}getChannels(){return this.channels}async removeChannel(channel){const status=await channel.unsubscribe();return this.channels.length===0&&this.disconnect(),status}async removeAllChannels(){const values_1=await Promise.all(this.channels.map(channel=>channel.unsubscribe()));return this.channels=[],this.disconnect(),values_1}log(kind,msg,data){this.logger(kind,msg,data)}connectionState(){switch(this.conn&&this.conn.readyState){case SOCKET_STATES.connecting:return CONNECTION_STATE.Connecting;case SOCKET_STATES.open:return CONNECTION_STATE.Open;case SOCKET_STATES.closing:return CONNECTION_STATE.Closing;default:return CONNECTION_STATE.Closed}}isConnected(){return this.connectionState()===CONNECTION_STATE.Open}channel(topic,params={config:{}}){const realtimeTopic=`realtime:${topic}`,exists=this.getChannels().find(c=>c.topic===realtimeTopic);if(exists)return exists;{const chan=new RealtimeChannel(`realtime:${topic}`,params,this);return this.channels.push(chan),chan}}push(data){const{topic,event,payload,ref}=data,callback=()=>{this.encode(data,result=>{var _a;(_a=this.conn)===null||_a===void 0||_a.send(result)})};this.log("push",`${topic} ${event} (${ref})`,payload),this.isConnected()?callback():this.sendBuffer.push(callback)}async setAuth(token=null){let tokenToSend=token||this.accessToken&&await this.accessToken()||this.accessTokenValue;this.accessTokenValue!=tokenToSend&&(this.accessTokenValue=tokenToSend,this.channels.forEach(channel=>{const payload={access_token:tokenToSend,version:DEFAULT_VERSION};tokenToSend&&channel.updateJoinPayload(payload),channel.joinedOnce&&channel._isJoined()&&channel._push(CHANNEL_EVENTS.access_token,{access_token:tokenToSend})}))}async sendHeartbeat(){var _a;if(!this.isConnected()){this.heartbeatCallback("disconnected");return}if(this.pendingHeartbeatRef){this.pendingHeartbeatRef=null,this.log("transport","heartbeat timeout. Attempting to re-establish connection"),this.heartbeatCallback("timeout"),(_a=this.conn)===null||_a===void 0||_a.close(WS_CLOSE_NORMAL,"hearbeat timeout");return}this.pendingHeartbeatRef=this._makeRef(),this.push({topic:"phoenix",event:"heartbeat",payload:{},ref:this.pendingHeartbeatRef}),this.heartbeatCallback("sent"),await this.setAuth()}onHeartbeat(callback){this.heartbeatCallback=callback}flushSendBuffer(){this.isConnected()&&this.sendBuffer.length>0&&(this.sendBuffer.forEach(callback=>callback()),this.sendBuffer=[])}_makeRef(){let newRef=this.ref+1;return newRef===this.ref?this.ref=0:this.ref=newRef,this.ref.toString()}_leaveOpenTopic(topic){let dupChannel=this.channels.find(c=>c.topic===topic&&(c._isJoined()||c._isJoining()));dupChannel&&(this.log("transport",`leaving duplicate topic "${topic}"`),dupChannel.unsubscribe())}_remove(channel){this.channels=this.channels.filter(c=>c.topic!==channel.topic)}setupConnection(){this.conn&&(this.conn.binaryType="arraybuffer",this.conn.onopen=()=>this._onConnOpen(),this.conn.onerror=error=>this._onConnError(error),this.conn.onmessage=event=>this._onConnMessage(event),this.conn.onclose=event=>this._onConnClose(event))}_onConnMessage(rawMessage){this.decode(rawMessage.data,msg=>{let{topic,event,payload,ref}=msg;topic==="phoenix"&&event==="phx_reply"&&this.heartbeatCallback(msg.payload.status=="ok"?"ok":"error"),ref&&ref===this.pendingHeartbeatRef&&(this.pendingHeartbeatRef=null),this.log("receive",`${payload.status||""} ${topic} ${event} ${ref&&"("+ref+")"||""}`,payload),Array.from(this.channels).filter(channel=>channel._isMember(topic)).forEach(channel=>channel._trigger(event,payload,ref)),this.stateChangeCallbacks.message.forEach(callback=>callback(msg))})}_onConnOpen(){this.log("transport",`connected to ${this.endpointURL()}`),this.flushSendBuffer(),this.reconnectTimer.reset(),this.worker?this.workerRef||this._startWorkerHeartbeat():this._startHeartbeat(),this.stateChangeCallbacks.open.forEach(callback=>callback())}_startHeartbeat(){this.heartbeatTimer&&clearInterval(this.heartbeatTimer),this.heartbeatTimer=setInterval(()=>this.sendHeartbeat(),this.heartbeatIntervalMs)}_startWorkerHeartbeat(){this.workerUrl?this.log("worker",`starting worker for from ${this.workerUrl}`):this.log("worker","starting default worker");const objectUrl=this._workerObjectUrl(this.workerUrl);this.workerRef=new Worker(objectUrl),this.workerRef.onerror=error=>{this.log("worker","worker error",error.message),this.workerRef.terminate()},this.workerRef.onmessage=event=>{event.data.event==="keepAlive"&&this.sendHeartbeat()},this.workerRef.postMessage({event:"start",interval:this.heartbeatIntervalMs})}_onConnClose(event){this.log("transport","close",event),this._triggerChanError(),this.heartbeatTimer&&clearInterval(this.heartbeatTimer),this.reconnectTimer.scheduleTimeout(),this.stateChangeCallbacks.close.forEach(callback=>callback(event))}_onConnError(error){this.log("transport",`${error}`),this._triggerChanError(),this.stateChangeCallbacks.error.forEach(callback=>callback(error))}_triggerChanError(){this.channels.forEach(channel=>channel._trigger(CHANNEL_EVENTS.error))}_appendParams(url,params){if(Object.keys(params).length===0)return url;const prefix=url.match(/\?/)?"&":"?",query=new URLSearchParams(params);return`${url}${prefix}${query}`}_workerObjectUrl(url){let result_url;if(url)result_url=url;else{const blob=new Blob([WORKER_SCRIPT],{type:"application/javascript"});result_url=URL.createObjectURL(blob)}return result_url}}class StorageError extends Error{constructor(message){super(message),this.__isStorageError=!0,this.name="StorageError"}}function isStorageError(error){return typeof error=="object"&&error!==null&&"__isStorageError"in error}class StorageApiError extends StorageError{constructor(message,status){super(message),this.name="StorageApiError",this.status=status}toJSON(){return{name:this.name,message:this.message,status:this.status}}}class StorageUnknownError extends StorageError{constructor(message,originalError){super(message),this.name="StorageUnknownError",this.originalError=originalError}}var __awaiter$6=function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator.throw(value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};const resolveFetch$2=customFetch=>{let _fetch;return customFetch?_fetch=customFetch:typeof fetch>"u"?_fetch=(...args)=>__vitePreload(async()=>{const{default:fetch2}=await Promise.resolve().then(()=>browser);return{default:fetch2}},void 0).then(({default:fetch2})=>fetch2(...args)):_fetch=fetch,(...args)=>_fetch(...args)},resolveResponse=()=>__awaiter$6(void 0,void 0,void 0,function*(){return typeof Response>"u"?(yield __vitePreload(()=>Promise.resolve().then(()=>browser),void 0)).Response:Response}),recursiveToCamel=item=>{if(Array.isArray(item))return item.map(el=>recursiveToCamel(el));if(typeof item=="function"||item!==Object(item))return item;const result={};return Object.entries(item).forEach(([key,value])=>{const newKey=key.replace(/([-_][a-z])/gi,c=>c.toUpperCase().replace(/[-_]/g,""));result[newKey]=recursiveToCamel(value)}),result};var __awaiter$5=function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator.throw(value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};const _getErrorMessage$1=err=>err.msg||err.message||err.error_description||err.error||JSON.stringify(err),handleError$1=(error,reject,options)=>__awaiter$5(void 0,void 0,void 0,function*(){const Res=yield resolveResponse();error instanceof Res&&!options?.noResolveJson?error.json().then(err=>{reject(new StorageApiError(_getErrorMessage$1(err),error.status||500))}).catch(err=>{reject(new StorageUnknownError(_getErrorMessage$1(err),err))}):reject(new StorageUnknownError(_getErrorMessage$1(error),error))}),_getRequestParams$1=(method,options,parameters,body)=>{const params={method,headers:options?.headers||{}};return method==="GET"?params:(params.headers=Object.assign({"Content-Type":"application/json"},options?.headers),body&&(params.body=JSON.stringify(body)),Object.assign(Object.assign({},params),parameters))};function _handleRequest$1(fetcher,method,url,options,parameters,body){return __awaiter$5(this,void 0,void 0,function*(){return new Promise((resolve,reject)=>{fetcher(url,_getRequestParams$1(method,options,parameters,body)).then(result=>{if(!result.ok)throw result;return options?.noResolveJson?result:result.json()}).then(data=>resolve(data)).catch(error=>handleError$1(error,reject,options))})})}function get(fetcher,url,options,parameters){return __awaiter$5(this,void 0,void 0,function*(){return _handleRequest$1(fetcher,"GET",url,options,parameters)})}function post(fetcher,url,body,options,parameters){return __awaiter$5(this,void 0,void 0,function*(){return _handleRequest$1(fetcher,"POST",url,options,parameters,body)})}function put(fetcher,url,body,options,parameters){return __awaiter$5(this,void 0,void 0,function*(){return _handleRequest$1(fetcher,"PUT",url,options,parameters,body)})}function head(fetcher,url,options,parameters){return __awaiter$5(this,void 0,void 0,function*(){return _handleRequest$1(fetcher,"HEAD",url,Object.assign(Object.assign({},options),{noResolveJson:!0}),parameters)})}function remove(fetcher,url,body,options,parameters){return __awaiter$5(this,void 0,void 0,function*(){return _handleRequest$1(fetcher,"DELETE",url,options,parameters,body)})}var __awaiter$4=function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator.throw(value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};const DEFAULT_SEARCH_OPTIONS={limit:100,offset:0,sortBy:{column:"name",order:"asc"}},DEFAULT_FILE_OPTIONS={cacheControl:"3600",contentType:"text/plain;charset=UTF-8",upsert:!1};class StorageFileApi{constructor(url,headers={},bucketId,fetch2){this.url=url,this.headers=headers,this.bucketId=bucketId,this.fetch=resolveFetch$2(fetch2)}uploadOrUpdate(method,path,fileBody,fileOptions){return __awaiter$4(this,void 0,void 0,function*(){try{let body;const options=Object.assign(Object.assign({},DEFAULT_FILE_OPTIONS),fileOptions);let headers=Object.assign(Object.assign({},this.headers),method==="POST"&&{"x-upsert":String(options.upsert)});const metadata=options.metadata;typeof Blob<"u"&&fileBody instanceof Blob?(body=new FormData,body.append("cacheControl",options.cacheControl),metadata&&body.append("metadata",this.encodeMetadata(metadata)),body.append("",fileBody)):typeof FormData<"u"&&fileBody instanceof FormData?(body=fileBody,body.append("cacheControl",options.cacheControl),metadata&&body.append("metadata",this.encodeMetadata(metadata))):(body=fileBody,headers["cache-control"]=`max-age=${options.cacheControl}`,headers["content-type"]=options.contentType,metadata&&(headers["x-metadata"]=this.toBase64(this.encodeMetadata(metadata)))),fileOptions?.headers&&(headers=Object.assign(Object.assign({},headers),fileOptions.headers));const cleanPath=this._removeEmptyFolders(path),_path=this._getFinalPath(cleanPath),res=yield this.fetch(`${this.url}/object/${_path}`,Object.assign({method,body,headers},options?.duplex?{duplex:options.duplex}:{})),data=yield res.json();return res.ok?{data:{path:cleanPath,id:data.Id,fullPath:data.Key},error:null}:{data:null,error:data}}catch(error){if(isStorageError(error))return{data:null,error};throw error}})}upload(path,fileBody,fileOptions){return __awaiter$4(this,void 0,void 0,function*(){return this.uploadOrUpdate("POST",path,fileBody,fileOptions)})}uploadToSignedUrl(path,token,fileBody,fileOptions){return __awaiter$4(this,void 0,void 0,function*(){const cleanPath=this._removeEmptyFolders(path),_path=this._getFinalPath(cleanPath),url=new URL(this.url+`/object/upload/sign/${_path}`);url.searchParams.set("token",token);try{let body;const options=Object.assign({upsert:DEFAULT_FILE_OPTIONS.upsert},fileOptions),headers=Object.assign(Object.assign({},this.headers),{"x-upsert":String(options.upsert)});typeof Blob<"u"&&fileBody instanceof Blob?(body=new FormData,body.append("cacheControl",options.cacheControl),body.append("",fileBody)):typeof FormData<"u"&&fileBody instanceof FormData?(body=fileBody,body.append("cacheControl",options.cacheControl)):(body=fileBody,headers["cache-control"]=`max-age=${options.cacheControl}`,headers["content-type"]=options.contentType);const res=yield this.fetch(url.toString(),{method:"PUT",body,headers}),data=yield res.json();return res.ok?{data:{path:cleanPath,fullPath:data.Key},error:null}:{data:null,error:data}}catch(error){if(isStorageError(error))return{data:null,error};throw error}})}createSignedUploadUrl(path,options){return __awaiter$4(this,void 0,void 0,function*(){try{let _path=this._getFinalPath(path);const headers=Object.assign({},this.headers);options?.upsert&&(headers["x-upsert"]="true");const data=yield post(this.fetch,`${this.url}/object/upload/sign/${_path}`,{},{headers}),url=new URL(this.url+data.url),token=url.searchParams.get("token");if(!token)throw new StorageError("No token returned by API");return{data:{signedUrl:url.toString(),path,token},error:null}}catch(error){if(isStorageError(error))return{data:null,error};throw error}})}update(path,fileBody,fileOptions){return __awaiter$4(this,void 0,void 0,function*(){return this.uploadOrUpdate("PUT",path,fileBody,fileOptions)})}move(fromPath,toPath,options){return __awaiter$4(this,void 0,void 0,function*(){try{return{data:yield post(this.fetch,`${this.url}/object/move`,{bucketId:this.bucketId,sourceKey:fromPath,destinationKey:toPath,destinationBucket:options?.destinationBucket},{headers:this.headers}),error:null}}catch(error){if(isStorageError(error))return{data:null,error};throw error}})}copy(fromPath,toPath,options){return __awaiter$4(this,void 0,void 0,function*(){try{return{data:{path:(yield post(this.fetch,`${this.url}/object/copy`,{bucketId:this.bucketId,sourceKey:fromPath,destinationKey:toPath,destinationBucket:options?.destinationBucket},{headers:this.headers})).Key},error:null}}catch(error){if(isStorageError(error))return{data:null,error};throw error}})}createSignedUrl(path,expiresIn,options){return __awaiter$4(this,void 0,void 0,function*(){try{let _path=this._getFinalPath(path),data=yield post(this.fetch,`${this.url}/object/sign/${_path}`,Object.assign({expiresIn},options?.transform?{transform:options.transform}:{}),{headers:this.headers});const downloadQueryParam=options?.download?`&download=${options.download===!0?"":options.download}`:"";return data={signedUrl:encodeURI(`${this.url}${data.signedURL}${downloadQueryParam}`)},{data,error:null}}catch(error){if(isStorageError(error))return{data:null,error};throw error}})}createSignedUrls(paths,expiresIn,options){return __awaiter$4(this,void 0,void 0,function*(){try{const data=yield post(this.fetch,`${this.url}/object/sign/${this.bucketId}`,{expiresIn,paths},{headers:this.headers}),downloadQueryParam=options?.download?`&download=${options.download===!0?"":options.download}`:"";return{data:data.map(datum=>Object.assign(Object.assign({},datum),{signedUrl:datum.signedURL?encodeURI(`${this.url}${datum.signedURL}${downloadQueryParam}`):null})),error:null}}catch(error){if(isStorageError(error))return{data:null,error};throw error}})}download(path,options){return __awaiter$4(this,void 0,void 0,function*(){const renderPath=typeof options?.transform<"u"?"render/image/authenticated":"object",transformationQuery=this.transformOptsToQueryString(options?.transform||{}),queryString=transformationQuery?`?${transformationQuery}`:"";try{const _path=this._getFinalPath(path);return{data:yield(yield get(this.fetch,`${this.url}/${renderPath}/${_path}${queryString}`,{headers:this.headers,noResolveJson:!0})).blob(),error:null}}catch(error){if(isStorageError(error))return{data:null,error};throw error}})}info(path){return __awaiter$4(this,void 0,void 0,function*(){const _path=this._getFinalPath(path);try{const data=yield get(this.fetch,`${this.url}/object/info/${_path}`,{headers:this.headers});return{data:recursiveToCamel(data),error:null}}catch(error){if(isStorageError(error))return{data:null,error};throw error}})}exists(path){return __awaiter$4(this,void 0,void 0,function*(){const _path=this._getFinalPath(path);try{return yield head(this.fetch,`${this.url}/object/${_path}`,{headers:this.headers}),{data:!0,error:null}}catch(error){if(isStorageError(error)&&error instanceof StorageUnknownError){const originalError=error.originalError;if([400,404].includes(originalError?.status))return{data:!1,error}}throw error}})}getPublicUrl(path,options){const _path=this._getFinalPath(path),_queryString=[],downloadQueryParam=options?.download?`download=${options.download===!0?"":options.download}`:"";downloadQueryParam!==""&&_queryString.push(downloadQueryParam);const renderPath=typeof options?.transform<"u"?"render/image":"object",transformationQuery=this.transformOptsToQueryString(options?.transform||{});transformationQuery!==""&&_queryString.push(transformationQuery);let queryString=_queryString.join("&");return queryString!==""&&(queryString=`?${queryString}`),{data:{publicUrl:encodeURI(`${this.url}/${renderPath}/public/${_path}${queryString}`)}}}remove(paths){return __awaiter$4(this,void 0,void 0,function*(){try{return{data:yield remove(this.fetch,`${this.url}/object/${this.bucketId}`,{prefixes:paths},{headers:this.headers}),error:null}}catch(error){if(isStorageError(error))return{data:null,error};throw error}})}list(path,options,parameters){return __awaiter$4(this,void 0,void 0,function*(){try{const body=Object.assign(Object.assign(Object.assign({},DEFAULT_SEARCH_OPTIONS),options),{prefix:path||""});return{data:yield post(this.fetch,`${this.url}/object/list/${this.bucketId}`,body,{headers:this.headers},parameters),error:null}}catch(error){if(isStorageError(error))return{data:null,error};throw error}})}encodeMetadata(metadata){return JSON.stringify(metadata)}toBase64(data){return typeof Buffer<"u"?Buffer.from(data).toString("base64"):btoa(data)}_getFinalPath(path){return`${this.bucketId}/${path}`}_removeEmptyFolders(path){return path.replace(/^\/|\/$/g,"").replace(/\/+/g,"/")}transformOptsToQueryString(transform){const params=[];return transform.width&&params.push(`width=${transform.width}`),transform.height&&params.push(`height=${transform.height}`),transform.resize&&params.push(`resize=${transform.resize}`),transform.format&&params.push(`format=${transform.format}`),transform.quality&&params.push(`quality=${transform.quality}`),params.join("&")}}const version$2="2.7.1",DEFAULT_HEADERS$2={"X-Client-Info":`storage-js/${version$2}`};var __awaiter$3=function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator.throw(value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,[])).next())})};class StorageBucketApi{constructor(url,headers={},fetch2){this.url=url,this.headers=Object.assign(Object.assign({},DEFAULT_HEADERS$2),headers),this.fetch=resolveFetch$2(fetch2)}listBuckets(){return __awaiter$3(this,void 0,void 0,function*(){try{return{data:yield get(this.fetch,`${this.url}/bucket`,{headers:this.headers}),error:null}}catch(error){if(isStorageError(error))return{data:null,error};throw error}})}getBucket(id){return __awaiter$3(this,void 0,void 0,function*(){try{return{data:yield get(this.fetch,`${this.url}/bucket/${id}`,{headers:this.headers}),error:null}}catch(error){if(isStorageError(error))return{data:null,error};throw error}})}createBucket(id,options={public:!1}){return __awaiter$3(this,void 0,void 0,function*(){try{return{data:yield post(this.fetch,`${this.url}/bucket`,{id,name:id,public:options.public,file_size_limit:options.fileSizeLimit,allowed_mime_types:options.allowedMimeTypes},{headers:this.headers}),error:null}}catch(error){if(isStorageError(error))return{data:null,error};throw error}})}updateBucket(id,options){return __awaiter$3(this,void 0,void 0,function*(){try{return{data:yield put(this.fetch,`${this.url}/bucket/${id}`,{id,name:id,public:options.public,file_size_limit:options.fileSizeLimit,allowed_mime_types:options.allowedMimeTypes},{headers:this.headers}),error:null}}catch(error){if(isStorageError(error))return{data:null,error};throw error}})}emptyBucket(id){return __awaiter$3(this,void 0,void 0,function*(){try{return{data:yield post(this.fetch,`${this.url}/bucket/${id}/empty`,{},{headers:this.headers}),error:null}}catch(error){if(isStorageError(error))return{data:null,error};throw error}})}deleteBucket(id){return __awaiter$3(this,void 0,void 0,function*(){try{return{data:yield remove(this.fetch,`${this.url}/bucket/${id}`,{},{headers:this.headers}),error:null}}catch(error){if(isStorageError(error))return{data:null,error};throw error}})}}class StorageClient extends StorageBucketApi{constructor(url,headers={},fetch2){super(url,headers,fetch2)}from(id){return new StorageFileApi(this.url,this.headers,id,this.fetch)}}const version$1="2.52.1";let JS_ENV="";typeof Deno<"u"?JS_ENV="deno":typeof document<"u"?JS_ENV="web":typeof navigator<"u"&&navigator.product==="ReactNative"?JS_ENV="react-native":JS_ENV="node";const DEFAULT_HEADERS$1={"X-Client-Info":`supabase-js-${JS_ENV}/${version$1}`},DEFAULT_GLOBAL_OPTIONS={headers:DEFAULT_HEADERS$1},DEFAULT_DB_OPTIONS={schema:"public"},DEFAULT_AUTH_OPTIONS={autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0,flowType:"implicit"},DEFAULT_REALTIME_OPTIONS={};var __awaiter$2=function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator.throw(value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};const resolveFetch$1=customFetch=>{let _fetch;return customFetch?_fetch=customFetch:typeof fetch>"u"?_fetch=nodeFetch:_fetch=fetch,(...args)=>_fetch(...args)},resolveHeadersConstructor=()=>typeof Headers>"u"?Headers$1:Headers,fetchWithAuth=(supabaseKey,getAccessToken,customFetch)=>{const fetch2=resolveFetch$1(customFetch),HeadersConstructor=resolveHeadersConstructor();return(input,init)=>__awaiter$2(void 0,void 0,void 0,function*(){var _a;const accessToken=(_a=yield getAccessToken())!==null&&_a!==void 0?_a:supabaseKey;let headers=new HeadersConstructor(init?.headers);return headers.has("apikey")||headers.set("apikey",supabaseKey),headers.has("Authorization")||headers.set("Authorization",`Bearer ${accessToken}`),fetch2(input,Object.assign(Object.assign({},init),{headers}))})};var __awaiter$1=function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator.throw(value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,[])).next())})};function ensureTrailingSlash(url){return url.endsWith("/")?url:url+"/"}function applySettingDefaults(options,defaults){var _a,_b;const{db:dbOptions,auth:authOptions,realtime:realtimeOptions,global:globalOptions}=options,{db:DEFAULT_DB_OPTIONS2,auth:DEFAULT_AUTH_OPTIONS2,realtime:DEFAULT_REALTIME_OPTIONS2,global:DEFAULT_GLOBAL_OPTIONS2}=defaults,result={db:Object.assign(Object.assign({},DEFAULT_DB_OPTIONS2),dbOptions),auth:Object.assign(Object.assign({},DEFAULT_AUTH_OPTIONS2),authOptions),realtime:Object.assign(Object.assign({},DEFAULT_REALTIME_OPTIONS2),realtimeOptions),global:Object.assign(Object.assign(Object.assign({},DEFAULT_GLOBAL_OPTIONS2),globalOptions),{headers:Object.assign(Object.assign({},(_a=DEFAULT_GLOBAL_OPTIONS2?.headers)!==null&&_a!==void 0?_a:{}),(_b=globalOptions?.headers)!==null&&_b!==void 0?_b:{})}),accessToken:()=>__awaiter$1(this,void 0,void 0,function*(){return""})};return options.accessToken?result.accessToken=options.accessToken:delete result.accessToken,result}const version="2.71.1",AUTO_REFRESH_TICK_DURATION_MS=30*1e3,AUTO_REFRESH_TICK_THRESHOLD=3,EXPIRY_MARGIN_MS=AUTO_REFRESH_TICK_THRESHOLD*AUTO_REFRESH_TICK_DURATION_MS,GOTRUE_URL="http://localhost:9999",STORAGE_KEY="supabase.auth.token",DEFAULT_HEADERS={"X-Client-Info":`gotrue-js/${version}`},API_VERSION_HEADER_NAME="X-Supabase-Api-Version",API_VERSIONS={"2024-01-01":{timestamp:Date.parse("2024-01-01T00:00:00.0Z"),name:"2024-01-01"}},BASE64URL_REGEX=/^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i,JWKS_TTL=10*60*1e3;class AuthError extends Error{constructor(message,status,code){super(message),this.__isAuthError=!0,this.name="AuthError",this.status=status,this.code=code}}function isAuthError(error){return typeof error=="object"&&error!==null&&"__isAuthError"in error}class AuthApiError extends AuthError{constructor(message,status,code){super(message,status,code),this.name="AuthApiError",this.status=status,this.code=code}}function isAuthApiError(error){return isAuthError(error)&&error.name==="AuthApiError"}class AuthUnknownError extends AuthError{constructor(message,originalError){super(message),this.name="AuthUnknownError",this.originalError=originalError}}class CustomAuthError extends AuthError{constructor(message,name,status,code){super(message,status,code),this.name=name,this.status=status}}class AuthSessionMissingError extends CustomAuthError{constructor(){super("Auth session missing!","AuthSessionMissingError",400,void 0)}}function isAuthSessionMissingError(error){return isAuthError(error)&&error.name==="AuthSessionMissingError"}class AuthInvalidTokenResponseError extends CustomAuthError{constructor(){super("Auth session or user missing","AuthInvalidTokenResponseError",500,void 0)}}class AuthInvalidCredentialsError extends CustomAuthError{constructor(message){super(message,"AuthInvalidCredentialsError",400,void 0)}}class AuthImplicitGrantRedirectError extends CustomAuthError{constructor(message,details=null){super(message,"AuthImplicitGrantRedirectError",500,void 0),this.details=null,this.details=details}toJSON(){return{name:this.name,message:this.message,status:this.status,details:this.details}}}function isAuthImplicitGrantRedirectError(error){return isAuthError(error)&&error.name==="AuthImplicitGrantRedirectError"}class AuthPKCEGrantCodeExchangeError extends CustomAuthError{constructor(message,details=null){super(message,"AuthPKCEGrantCodeExchangeError",500,void 0),this.details=null,this.details=details}toJSON(){return{name:this.name,message:this.message,status:this.status,details:this.details}}}class AuthRetryableFetchError extends CustomAuthError{constructor(message,status){super(message,"AuthRetryableFetchError",status,void 0)}}function isAuthRetryableFetchError(error){return isAuthError(error)&&error.name==="AuthRetryableFetchError"}class AuthWeakPasswordError extends CustomAuthError{constructor(message,status,reasons){super(message,"AuthWeakPasswordError",status,"weak_password"),this.reasons=reasons}}class AuthInvalidJwtError extends CustomAuthError{constructor(message){super(message,"AuthInvalidJwtError",400,"invalid_jwt")}}const TO_BASE64URL="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split(""),IGNORE_BASE64URL=` 	
\r=`.split(""),FROM_BASE64URL=(()=>{const charMap=new Array(128);for(let i=0;i<charMap.length;i+=1)charMap[i]=-1;for(let i=0;i<IGNORE_BASE64URL.length;i+=1)charMap[IGNORE_BASE64URL[i].charCodeAt(0)]=-2;for(let i=0;i<TO_BASE64URL.length;i+=1)charMap[TO_BASE64URL[i].charCodeAt(0)]=i;return charMap})();function byteToBase64URL(byte,state,emit){if(byte!==null)for(state.queue=state.queue<<8|byte,state.queuedBits+=8;state.queuedBits>=6;){const pos=state.queue>>state.queuedBits-6&63;emit(TO_BASE64URL[pos]),state.queuedBits-=6}else if(state.queuedBits>0)for(state.queue=state.queue<<6-state.queuedBits,state.queuedBits=6;state.queuedBits>=6;){const pos=state.queue>>state.queuedBits-6&63;emit(TO_BASE64URL[pos]),state.queuedBits-=6}}function byteFromBase64URL(charCode,state,emit){const bits=FROM_BASE64URL[charCode];if(bits>-1)for(state.queue=state.queue<<6|bits,state.queuedBits+=6;state.queuedBits>=8;)emit(state.queue>>state.queuedBits-8&255),state.queuedBits-=8;else{if(bits===-2)return;throw new Error(`Invalid Base64-URL character "${String.fromCharCode(charCode)}"`)}}function stringFromBase64URL(str){const conv=[],utf8Emit=codepoint=>{conv.push(String.fromCodePoint(codepoint))},utf8State={utf8seq:0,codepoint:0},b64State={queue:0,queuedBits:0},byteEmit=byte=>{stringFromUTF8(byte,utf8State,utf8Emit)};for(let i=0;i<str.length;i+=1)byteFromBase64URL(str.charCodeAt(i),b64State,byteEmit);return conv.join("")}function codepointToUTF8(codepoint,emit){if(codepoint<=127){emit(codepoint);return}else if(codepoint<=2047){emit(192|codepoint>>6),emit(128|codepoint&63);return}else if(codepoint<=65535){emit(224|codepoint>>12),emit(128|codepoint>>6&63),emit(128|codepoint&63);return}else if(codepoint<=1114111){emit(240|codepoint>>18),emit(128|codepoint>>12&63),emit(128|codepoint>>6&63),emit(128|codepoint&63);return}throw new Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`)}function stringToUTF8(str,emit){for(let i=0;i<str.length;i+=1){let codepoint=str.charCodeAt(i);if(codepoint>55295&&codepoint<=56319){const highSurrogate=(codepoint-55296)*1024&65535;codepoint=(str.charCodeAt(i+1)-56320&65535|highSurrogate)+65536,i+=1}codepointToUTF8(codepoint,emit)}}function stringFromUTF8(byte,state,emit){if(state.utf8seq===0){if(byte<=127){emit(byte);return}for(let leadingBit=1;leadingBit<6;leadingBit+=1)if(!(byte>>7-leadingBit&1)){state.utf8seq=leadingBit;break}if(state.utf8seq===2)state.codepoint=byte&31;else if(state.utf8seq===3)state.codepoint=byte&15;else if(state.utf8seq===4)state.codepoint=byte&7;else throw new Error("Invalid UTF-8 sequence");state.utf8seq-=1}else if(state.utf8seq>0){if(byte<=127)throw new Error("Invalid UTF-8 sequence");state.codepoint=state.codepoint<<6|byte&63,state.utf8seq-=1,state.utf8seq===0&&emit(state.codepoint)}}function base64UrlToUint8Array(str){const result=[],state={queue:0,queuedBits:0},onByte=byte=>{result.push(byte)};for(let i=0;i<str.length;i+=1)byteFromBase64URL(str.charCodeAt(i),state,onByte);return new Uint8Array(result)}function stringToUint8Array(str){const result=[];return stringToUTF8(str,byte=>result.push(byte)),new Uint8Array(result)}function bytesToBase64URL(bytes){const result=[],state={queue:0,queuedBits:0},onChar=char=>{result.push(char)};return bytes.forEach(byte=>byteToBase64URL(byte,state,onChar)),byteToBase64URL(null,state,onChar),result.join("")}function expiresAt(expiresIn){return Math.round(Date.now()/1e3)+expiresIn}function uuid(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(c){const r=Math.random()*16|0;return(c=="x"?r:r&3|8).toString(16)})}const isBrowser=()=>typeof window<"u"&&typeof document<"u",localStorageWriteTests={tested:!1,writable:!1},supportsLocalStorage=()=>{if(!isBrowser())return!1;try{if(typeof globalThis.localStorage!="object")return!1}catch{return!1}if(localStorageWriteTests.tested)return localStorageWriteTests.writable;const randomKey=`lswt-${Math.random()}${Math.random()}`;try{globalThis.localStorage.setItem(randomKey,randomKey),globalThis.localStorage.removeItem(randomKey),localStorageWriteTests.tested=!0,localStorageWriteTests.writable=!0}catch{localStorageWriteTests.tested=!0,localStorageWriteTests.writable=!1}return localStorageWriteTests.writable};function parseParametersFromURL(href){const result={},url=new URL(href);if(url.hash&&url.hash[0]==="#")try{new URLSearchParams(url.hash.substring(1)).forEach((value,key)=>{result[key]=value})}catch{}return url.searchParams.forEach((value,key)=>{result[key]=value}),result}const resolveFetch=customFetch=>{let _fetch;return customFetch?_fetch=customFetch:typeof fetch>"u"?_fetch=(...args)=>__vitePreload(async()=>{const{default:fetch2}=await Promise.resolve().then(()=>browser);return{default:fetch2}},void 0).then(({default:fetch2})=>fetch2(...args)):_fetch=fetch,(...args)=>_fetch(...args)},looksLikeFetchResponse=maybeResponse=>typeof maybeResponse=="object"&&maybeResponse!==null&&"status"in maybeResponse&&"ok"in maybeResponse&&"json"in maybeResponse&&typeof maybeResponse.json=="function",setItemAsync=async(storage,key,data)=>{await storage.setItem(key,JSON.stringify(data))},getItemAsync=async(storage,key)=>{const value=await storage.getItem(key);if(!value)return null;try{return JSON.parse(value)}catch{return value}},removeItemAsync=async(storage,key)=>{await storage.removeItem(key)};class Deferred{constructor(){this.promise=new Deferred.promiseConstructor((res,rej)=>{this.resolve=res,this.reject=rej})}}Deferred.promiseConstructor=Promise;function decodeJWT(token){const parts=token.split(".");if(parts.length!==3)throw new AuthInvalidJwtError("Invalid JWT structure");for(let i=0;i<parts.length;i++)if(!BASE64URL_REGEX.test(parts[i]))throw new AuthInvalidJwtError("JWT not in base64url format");return{header:JSON.parse(stringFromBase64URL(parts[0])),payload:JSON.parse(stringFromBase64URL(parts[1])),signature:base64UrlToUint8Array(parts[2]),raw:{header:parts[0],payload:parts[1]}}}async function sleep(time){return await new Promise(accept=>{setTimeout(()=>accept(null),time)})}function retryable(fn,isRetryable){return new Promise((accept,reject)=>{(async()=>{for(let attempt=0;attempt<1/0;attempt++)try{const result=await fn(attempt);if(!isRetryable(attempt,null,result)){accept(result);return}}catch(e){if(!isRetryable(attempt,e)){reject(e);return}}})()})}function dec2hex(dec){return("0"+dec.toString(16)).substr(-2)}function generatePKCEVerifier(){const array=new Uint32Array(56);if(typeof crypto>"u"){const charSet="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~",charSetLen=charSet.length;let verifier="";for(let i=0;i<56;i++)verifier+=charSet.charAt(Math.floor(Math.random()*charSetLen));return verifier}return crypto.getRandomValues(array),Array.from(array,dec2hex).join("")}async function sha256(randomString){const encodedData=new TextEncoder().encode(randomString),hash=await crypto.subtle.digest("SHA-256",encodedData),bytes=new Uint8Array(hash);return Array.from(bytes).map(c=>String.fromCharCode(c)).join("")}async function generatePKCEChallenge(verifier){if(!(typeof crypto<"u"&&typeof crypto.subtle<"u"&&typeof TextEncoder<"u"))return console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256."),verifier;const hashed=await sha256(verifier);return btoa(hashed).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}async function getCodeChallengeAndMethod(storage,storageKey,isPasswordRecovery=!1){const codeVerifier=generatePKCEVerifier();let storedCodeVerifier=codeVerifier;isPasswordRecovery&&(storedCodeVerifier+="/PASSWORD_RECOVERY"),await setItemAsync(storage,`${storageKey}-code-verifier`,storedCodeVerifier);const codeChallenge=await generatePKCEChallenge(codeVerifier);return[codeChallenge,codeVerifier===codeChallenge?"plain":"s256"]}const API_VERSION_REGEX=/^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;function parseResponseAPIVersion(response){const apiVersion=response.headers.get(API_VERSION_HEADER_NAME);if(!apiVersion||!apiVersion.match(API_VERSION_REGEX))return null;try{return new Date(`${apiVersion}T00:00:00.0Z`)}catch{return null}}function validateExp(exp){if(!exp)throw new Error("Missing exp claim");const timeNow=Math.floor(Date.now()/1e3);if(exp<=timeNow)throw new Error("JWT has expired")}function getAlgorithm(alg){switch(alg){case"RS256":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}};case"ES256":return{name:"ECDSA",namedCurve:"P-256",hash:{name:"SHA-256"}};default:throw new Error("Invalid alg claim")}}const UUID_REGEX=/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;function validateUUID(str){if(!UUID_REGEX.test(str))throw new Error("@supabase/auth-js: Expected parameter to be UUID but is not")}function userNotAvailableProxy(){const proxyTarget={};return new Proxy(proxyTarget,{get:(target,prop)=>{if(prop==="__isUserNotAvailableProxy")return!0;if(typeof prop=="symbol"){const sProp=prop.toString();if(sProp==="Symbol(Symbol.toPrimitive)"||sProp==="Symbol(Symbol.toStringTag)"||sProp==="Symbol(util.inspect.custom)")return}throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the "${prop}" property of the session object is not supported. Please use getUser() instead.`)},set:(_target,prop)=>{throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the "${prop}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)},deleteProperty:(_target,prop)=>{throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the "${prop}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)}})}function deepClone(obj){return JSON.parse(JSON.stringify(obj))}var __rest$1=function(s,e){var t={};for(var p in s)Object.prototype.hasOwnProperty.call(s,p)&&e.indexOf(p)<0&&(t[p]=s[p]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var i=0,p=Object.getOwnPropertySymbols(s);i<p.length;i++)e.indexOf(p[i])<0&&Object.prototype.propertyIsEnumerable.call(s,p[i])&&(t[p[i]]=s[p[i]]);return t};const _getErrorMessage=err=>err.msg||err.message||err.error_description||err.error||JSON.stringify(err),NETWORK_ERROR_CODES=[502,503,504];async function handleError(error){var _a;if(!looksLikeFetchResponse(error))throw new AuthRetryableFetchError(_getErrorMessage(error),0);if(NETWORK_ERROR_CODES.includes(error.status))throw new AuthRetryableFetchError(_getErrorMessage(error),error.status);let data;try{data=await error.json()}catch(e){throw new AuthUnknownError(_getErrorMessage(e),e)}let errorCode;const responseAPIVersion=parseResponseAPIVersion(error);if(responseAPIVersion&&responseAPIVersion.getTime()>=API_VERSIONS["2024-01-01"].timestamp&&typeof data=="object"&&data&&typeof data.code=="string"?errorCode=data.code:typeof data=="object"&&data&&typeof data.error_code=="string"&&(errorCode=data.error_code),errorCode){if(errorCode==="weak_password")throw new AuthWeakPasswordError(_getErrorMessage(data),error.status,((_a=data.weak_password)===null||_a===void 0?void 0:_a.reasons)||[]);if(errorCode==="session_not_found")throw new AuthSessionMissingError}else if(typeof data=="object"&&data&&typeof data.weak_password=="object"&&data.weak_password&&Array.isArray(data.weak_password.reasons)&&data.weak_password.reasons.length&&data.weak_password.reasons.reduce((a,i)=>a&&typeof i=="string",!0))throw new AuthWeakPasswordError(_getErrorMessage(data),error.status,data.weak_password.reasons);throw new AuthApiError(_getErrorMessage(data),error.status||500,errorCode)}const _getRequestParams=(method,options,parameters,body)=>{const params={method,headers:options?.headers||{}};return method==="GET"?params:(params.headers=Object.assign({"Content-Type":"application/json;charset=UTF-8"},options?.headers),params.body=JSON.stringify(body),Object.assign(Object.assign({},params),parameters))};async function _request(fetcher,method,url,options){var _a;const headers=Object.assign({},options?.headers);headers[API_VERSION_HEADER_NAME]||(headers[API_VERSION_HEADER_NAME]=API_VERSIONS["2024-01-01"].name),options?.jwt&&(headers.Authorization=`Bearer ${options.jwt}`);const qs=(_a=options?.query)!==null&&_a!==void 0?_a:{};options?.redirectTo&&(qs.redirect_to=options.redirectTo);const queryString=Object.keys(qs).length?"?"+new URLSearchParams(qs).toString():"",data=await _handleRequest(fetcher,method,url+queryString,{headers,noResolveJson:options?.noResolveJson},{},options?.body);return options?.xform?options?.xform(data):{data:Object.assign({},data),error:null}}async function _handleRequest(fetcher,method,url,options,parameters,body){const requestParams=_getRequestParams(method,options,parameters,body);let result;try{result=await fetcher(url,Object.assign({},requestParams))}catch(e){throw console.error(e),new AuthRetryableFetchError(_getErrorMessage(e),0)}if(result.ok||await handleError(result),options?.noResolveJson)return result;try{return await result.json()}catch(e){await handleError(e)}}function _sessionResponse(data){var _a;let session=null;hasSession(data)&&(session=Object.assign({},data),data.expires_at||(session.expires_at=expiresAt(data.expires_in)));const user=(_a=data.user)!==null&&_a!==void 0?_a:data;return{data:{session,user},error:null}}function _sessionResponsePassword(data){const response=_sessionResponse(data);return!response.error&&data.weak_password&&typeof data.weak_password=="object"&&Array.isArray(data.weak_password.reasons)&&data.weak_password.reasons.length&&data.weak_password.message&&typeof data.weak_password.message=="string"&&data.weak_password.reasons.reduce((a,i)=>a&&typeof i=="string",!0)&&(response.data.weak_password=data.weak_password),response}function _userResponse(data){var _a;return{data:{user:(_a=data.user)!==null&&_a!==void 0?_a:data},error:null}}function _ssoResponse(data){return{data,error:null}}function _generateLinkResponse(data){const{action_link,email_otp,hashed_token,redirect_to,verification_type}=data,rest=__rest$1(data,["action_link","email_otp","hashed_token","redirect_to","verification_type"]),properties={action_link,email_otp,hashed_token,redirect_to,verification_type},user=Object.assign({},rest);return{data:{properties,user},error:null}}function _noResolveJsonResponse(data){return data}function hasSession(data){return data.access_token&&data.refresh_token&&data.expires_in}const SIGN_OUT_SCOPES=["global","local","others"];var __rest=function(s,e){var t={};for(var p in s)Object.prototype.hasOwnProperty.call(s,p)&&e.indexOf(p)<0&&(t[p]=s[p]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var i=0,p=Object.getOwnPropertySymbols(s);i<p.length;i++)e.indexOf(p[i])<0&&Object.prototype.propertyIsEnumerable.call(s,p[i])&&(t[p[i]]=s[p[i]]);return t};class GoTrueAdminApi{constructor({url="",headers={},fetch:fetch2}){this.url=url,this.headers=headers,this.fetch=resolveFetch(fetch2),this.mfa={listFactors:this._listFactors.bind(this),deleteFactor:this._deleteFactor.bind(this)}}async signOut(jwt,scope=SIGN_OUT_SCOPES[0]){if(SIGN_OUT_SCOPES.indexOf(scope)<0)throw new Error(`@supabase/auth-js: Parameter scope must be one of ${SIGN_OUT_SCOPES.join(", ")}`);try{return await _request(this.fetch,"POST",`${this.url}/logout?scope=${scope}`,{headers:this.headers,jwt,noResolveJson:!0}),{data:null,error:null}}catch(error){if(isAuthError(error))return{data:null,error};throw error}}async inviteUserByEmail(email,options={}){try{return await _request(this.fetch,"POST",`${this.url}/invite`,{body:{email,data:options.data},headers:this.headers,redirectTo:options.redirectTo,xform:_userResponse})}catch(error){if(isAuthError(error))return{data:{user:null},error};throw error}}async generateLink(params){try{const{options}=params,rest=__rest(params,["options"]),body=Object.assign(Object.assign({},rest),options);return"newEmail"in rest&&(body.new_email=rest?.newEmail,delete body.newEmail),await _request(this.fetch,"POST",`${this.url}/admin/generate_link`,{body,headers:this.headers,xform:_generateLinkResponse,redirectTo:options?.redirectTo})}catch(error){if(isAuthError(error))return{data:{properties:null,user:null},error};throw error}}async createUser(attributes){try{return await _request(this.fetch,"POST",`${this.url}/admin/users`,{body:attributes,headers:this.headers,xform:_userResponse})}catch(error){if(isAuthError(error))return{data:{user:null},error};throw error}}async listUsers(params){var _a,_b,_c,_d,_e,_f,_g;try{const pagination={nextPage:null,lastPage:0,total:0},response=await _request(this.fetch,"GET",`${this.url}/admin/users`,{headers:this.headers,noResolveJson:!0,query:{page:(_b=(_a=params?.page)===null||_a===void 0?void 0:_a.toString())!==null&&_b!==void 0?_b:"",per_page:(_d=(_c=params?.perPage)===null||_c===void 0?void 0:_c.toString())!==null&&_d!==void 0?_d:""},xform:_noResolveJsonResponse});if(response.error)throw response.error;const users=await response.json(),total=(_e=response.headers.get("x-total-count"))!==null&&_e!==void 0?_e:0,links=(_g=(_f=response.headers.get("link"))===null||_f===void 0?void 0:_f.split(","))!==null&&_g!==void 0?_g:[];return links.length>0&&(links.forEach(link=>{const page=parseInt(link.split(";")[0].split("=")[1].substring(0,1)),rel=JSON.parse(link.split(";")[1].split("=")[1]);pagination[`${rel}Page`]=page}),pagination.total=parseInt(total)),{data:Object.assign(Object.assign({},users),pagination),error:null}}catch(error){if(isAuthError(error))return{data:{users:[]},error};throw error}}async getUserById(uid){validateUUID(uid);try{return await _request(this.fetch,"GET",`${this.url}/admin/users/${uid}`,{headers:this.headers,xform:_userResponse})}catch(error){if(isAuthError(error))return{data:{user:null},error};throw error}}async updateUserById(uid,attributes){validateUUID(uid);try{return await _request(this.fetch,"PUT",`${this.url}/admin/users/${uid}`,{body:attributes,headers:this.headers,xform:_userResponse})}catch(error){if(isAuthError(error))return{data:{user:null},error};throw error}}async deleteUser(id,shouldSoftDelete=!1){validateUUID(id);try{return await _request(this.fetch,"DELETE",`${this.url}/admin/users/${id}`,{headers:this.headers,body:{should_soft_delete:shouldSoftDelete},xform:_userResponse})}catch(error){if(isAuthError(error))return{data:{user:null},error};throw error}}async _listFactors(params){validateUUID(params.userId);try{const{data,error}=await _request(this.fetch,"GET",`${this.url}/admin/users/${params.userId}/factors`,{headers:this.headers,xform:factors=>({data:{factors},error:null})});return{data,error}}catch(error){if(isAuthError(error))return{data:null,error};throw error}}async _deleteFactor(params){validateUUID(params.userId),validateUUID(params.id);try{return{data:await _request(this.fetch,"DELETE",`${this.url}/admin/users/${params.userId}/factors/${params.id}`,{headers:this.headers}),error:null}}catch(error){if(isAuthError(error))return{data:null,error};throw error}}}function memoryLocalStorageAdapter(store={}){return{getItem:key=>store[key]||null,setItem:(key,value)=>{store[key]=value},removeItem:key=>{delete store[key]}}}function polyfillGlobalThis(){if(typeof globalThis!="object")try{Object.defineProperty(Object.prototype,"__magic__",{get:function(){return this},configurable:!0}),__magic__.globalThis=__magic__,delete Object.prototype.__magic__}catch{typeof self<"u"&&(self.globalThis=self)}}const internals={debug:!!(globalThis&&supportsLocalStorage()&&globalThis.localStorage&&globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug")==="true")};class LockAcquireTimeoutError extends Error{constructor(message){super(message),this.isAcquireTimeout=!0}}class NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError{}async function navigatorLock(name,acquireTimeout,fn){internals.debug&&console.log("@supabase/gotrue-js: navigatorLock: acquire lock",name,acquireTimeout);const abortController=new globalThis.AbortController;return acquireTimeout>0&&setTimeout(()=>{abortController.abort(),internals.debug&&console.log("@supabase/gotrue-js: navigatorLock acquire timed out",name)},acquireTimeout),await Promise.resolve().then(()=>globalThis.navigator.locks.request(name,acquireTimeout===0?{mode:"exclusive",ifAvailable:!0}:{mode:"exclusive",signal:abortController.signal},async lock=>{if(lock){internals.debug&&console.log("@supabase/gotrue-js: navigatorLock: acquired",name,lock.name);try{return await fn()}finally{internals.debug&&console.log("@supabase/gotrue-js: navigatorLock: released",name,lock.name)}}else{if(acquireTimeout===0)throw internals.debug&&console.log("@supabase/gotrue-js: navigatorLock: not immediately available",name),new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock "${name}" immediately failed`);if(internals.debug)try{const result=await globalThis.navigator.locks.query();console.log("@supabase/gotrue-js: Navigator LockManager state",JSON.stringify(result,null,"  "))}catch(e){console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state",e)}return console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request"),await fn()}}))}polyfillGlobalThis();const DEFAULT_OPTIONS={url:GOTRUE_URL,storageKey:STORAGE_KEY,autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0,headers:DEFAULT_HEADERS,flowType:"implicit",debug:!1,hasCustomAuthorizationHeader:!1};async function lockNoOp(name,acquireTimeout,fn){return await fn()}const GLOBAL_JWKS={};class GoTrueClient{constructor(options){var _a,_b;this.userStorage=null,this.memoryStorage=null,this.stateChangeEmitters=new Map,this.autoRefreshTicker=null,this.visibilityChangedCallback=null,this.refreshingDeferred=null,this.initializePromise=null,this.detectSessionInUrl=!0,this.hasCustomAuthorizationHeader=!1,this.suppressGetSessionWarning=!1,this.lockAcquired=!1,this.pendingInLock=[],this.broadcastChannel=null,this.logger=console.log,this.instanceID=GoTrueClient.nextInstanceID,GoTrueClient.nextInstanceID+=1,this.instanceID>0&&isBrowser()&&console.warn("Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.");const settings=Object.assign(Object.assign({},DEFAULT_OPTIONS),options);if(this.logDebugMessages=!!settings.debug,typeof settings.debug=="function"&&(this.logger=settings.debug),this.persistSession=settings.persistSession,this.storageKey=settings.storageKey,this.autoRefreshToken=settings.autoRefreshToken,this.admin=new GoTrueAdminApi({url:settings.url,headers:settings.headers,fetch:settings.fetch}),this.url=settings.url,this.headers=settings.headers,this.fetch=resolveFetch(settings.fetch),this.lock=settings.lock||lockNoOp,this.detectSessionInUrl=settings.detectSessionInUrl,this.flowType=settings.flowType,this.hasCustomAuthorizationHeader=settings.hasCustomAuthorizationHeader,settings.lock?this.lock=settings.lock:isBrowser()&&(!((_a=globalThis?.navigator)===null||_a===void 0)&&_a.locks)?this.lock=navigatorLock:this.lock=lockNoOp,this.jwks||(this.jwks={keys:[]},this.jwks_cached_at=Number.MIN_SAFE_INTEGER),this.mfa={verify:this._verify.bind(this),enroll:this._enroll.bind(this),unenroll:this._unenroll.bind(this),challenge:this._challenge.bind(this),listFactors:this._listFactors.bind(this),challengeAndVerify:this._challengeAndVerify.bind(this),getAuthenticatorAssuranceLevel:this._getAuthenticatorAssuranceLevel.bind(this)},this.persistSession?(settings.storage?this.storage=settings.storage:supportsLocalStorage()?this.storage=globalThis.localStorage:(this.memoryStorage={},this.storage=memoryLocalStorageAdapter(this.memoryStorage)),settings.userStorage&&(this.userStorage=settings.userStorage)):(this.memoryStorage={},this.storage=memoryLocalStorageAdapter(this.memoryStorage)),isBrowser()&&globalThis.BroadcastChannel&&this.persistSession&&this.storageKey){try{this.broadcastChannel=new globalThis.BroadcastChannel(this.storageKey)}catch(e){console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available",e)}(_b=this.broadcastChannel)===null||_b===void 0||_b.addEventListener("message",async event=>{this._debug("received broadcast notification from other tab or client",event),await this._notifyAllSubscribers(event.data.event,event.data.session,!1)})}this.initialize()}get jwks(){var _a,_b;return(_b=(_a=GLOBAL_JWKS[this.storageKey])===null||_a===void 0?void 0:_a.jwks)!==null&&_b!==void 0?_b:{keys:[]}}set jwks(value){GLOBAL_JWKS[this.storageKey]=Object.assign(Object.assign({},GLOBAL_JWKS[this.storageKey]),{jwks:value})}get jwks_cached_at(){var _a,_b;return(_b=(_a=GLOBAL_JWKS[this.storageKey])===null||_a===void 0?void 0:_a.cachedAt)!==null&&_b!==void 0?_b:Number.MIN_SAFE_INTEGER}set jwks_cached_at(value){GLOBAL_JWKS[this.storageKey]=Object.assign(Object.assign({},GLOBAL_JWKS[this.storageKey]),{cachedAt:value})}_debug(...args){return this.logDebugMessages&&this.logger(`GoTrueClient@${this.instanceID} (${version}) ${new Date().toISOString()}`,...args),this}async initialize(){return this.initializePromise?await this.initializePromise:(this.initializePromise=(async()=>await this._acquireLock(-1,async()=>await this._initialize()))(),await this.initializePromise)}async _initialize(){var _a;try{const params=parseParametersFromURL(window.location.href);let callbackUrlType="none";if(this._isImplicitGrantCallback(params)?callbackUrlType="implicit":await this._isPKCECallback(params)&&(callbackUrlType="pkce"),isBrowser()&&this.detectSessionInUrl&&callbackUrlType!=="none"){const{data,error}=await this._getSessionFromURL(params,callbackUrlType);if(error){if(this._debug("#_initialize()","error detecting session from URL",error),isAuthImplicitGrantRedirectError(error)){const errorCode=(_a=error.details)===null||_a===void 0?void 0:_a.code;if(errorCode==="identity_already_exists"||errorCode==="identity_not_found"||errorCode==="single_identity_not_deletable")return{error}}return await this._removeSession(),{error}}const{session,redirectType}=data;return this._debug("#_initialize()","detected session in URL",session,"redirect type",redirectType),await this._saveSession(session),setTimeout(async()=>{redirectType==="recovery"?await this._notifyAllSubscribers("PASSWORD_RECOVERY",session):await this._notifyAllSubscribers("SIGNED_IN",session)},0),{error:null}}return await this._recoverAndRefresh(),{error:null}}catch(error){return isAuthError(error)?{error}:{error:new AuthUnknownError("Unexpected error during initialization",error)}}finally{await this._handleVisibilityChange(),this._debug("#_initialize()","end")}}async signInAnonymously(credentials){var _a,_b,_c;try{const res=await _request(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,body:{data:(_b=(_a=credentials?.options)===null||_a===void 0?void 0:_a.data)!==null&&_b!==void 0?_b:{},gotrue_meta_security:{captcha_token:(_c=credentials?.options)===null||_c===void 0?void 0:_c.captchaToken}},xform:_sessionResponse}),{data,error}=res;if(error||!data)return{data:{user:null,session:null},error};const session=data.session,user=data.user;return data.session&&(await this._saveSession(data.session),await this._notifyAllSubscribers("SIGNED_IN",session)),{data:{user,session},error:null}}catch(error){if(isAuthError(error))return{data:{user:null,session:null},error};throw error}}async signUp(credentials){var _a,_b,_c;try{let res;if("email"in credentials){const{email,password,options}=credentials;let codeChallenge=null,codeChallengeMethod=null;this.flowType==="pkce"&&([codeChallenge,codeChallengeMethod]=await getCodeChallengeAndMethod(this.storage,this.storageKey)),res=await _request(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,redirectTo:options?.emailRedirectTo,body:{email,password,data:(_a=options?.data)!==null&&_a!==void 0?_a:{},gotrue_meta_security:{captcha_token:options?.captchaToken},code_challenge:codeChallenge,code_challenge_method:codeChallengeMethod},xform:_sessionResponse})}else if("phone"in credentials){const{phone,password,options}=credentials;res=await _request(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,body:{phone,password,data:(_b=options?.data)!==null&&_b!==void 0?_b:{},channel:(_c=options?.channel)!==null&&_c!==void 0?_c:"sms",gotrue_meta_security:{captcha_token:options?.captchaToken}},xform:_sessionResponse})}else throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a password");const{data,error}=res;if(error||!data)return{data:{user:null,session:null},error};const session=data.session,user=data.user;return data.session&&(await this._saveSession(data.session),await this._notifyAllSubscribers("SIGNED_IN",session)),{data:{user,session},error:null}}catch(error){if(isAuthError(error))return{data:{user:null,session:null},error};throw error}}async signInWithPassword(credentials){try{let res;if("email"in credentials){const{email,password,options}=credentials;res=await _request(this.fetch,"POST",`${this.url}/token?grant_type=password`,{headers:this.headers,body:{email,password,gotrue_meta_security:{captcha_token:options?.captchaToken}},xform:_sessionResponsePassword})}else if("phone"in credentials){const{phone,password,options}=credentials;res=await _request(this.fetch,"POST",`${this.url}/token?grant_type=password`,{headers:this.headers,body:{phone,password,gotrue_meta_security:{captcha_token:options?.captchaToken}},xform:_sessionResponsePassword})}else throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a password");const{data,error}=res;return error?{data:{user:null,session:null},error}:!data||!data.session||!data.user?{data:{user:null,session:null},error:new AuthInvalidTokenResponseError}:(data.session&&(await this._saveSession(data.session),await this._notifyAllSubscribers("SIGNED_IN",data.session)),{data:Object.assign({user:data.user,session:data.session},data.weak_password?{weakPassword:data.weak_password}:null),error})}catch(error){if(isAuthError(error))return{data:{user:null,session:null},error};throw error}}async signInWithOAuth(credentials){var _a,_b,_c,_d;return await this._handleProviderSignIn(credentials.provider,{redirectTo:(_a=credentials.options)===null||_a===void 0?void 0:_a.redirectTo,scopes:(_b=credentials.options)===null||_b===void 0?void 0:_b.scopes,queryParams:(_c=credentials.options)===null||_c===void 0?void 0:_c.queryParams,skipBrowserRedirect:(_d=credentials.options)===null||_d===void 0?void 0:_d.skipBrowserRedirect})}async exchangeCodeForSession(authCode){return await this.initializePromise,this._acquireLock(-1,async()=>this._exchangeCodeForSession(authCode))}async signInWithWeb3(credentials){const{chain}=credentials;if(chain==="solana")return await this.signInWithSolana(credentials);throw new Error(`@supabase/auth-js: Unsupported chain "${chain}"`)}async signInWithSolana(credentials){var _a,_b,_c,_d,_e,_f,_g,_h,_j,_k,_l,_m;let message,signature;if("message"in credentials)message=credentials.message,signature=credentials.signature;else{const{chain,wallet,statement,options}=credentials;let resolvedWallet;if(isBrowser())if(typeof wallet=="object")resolvedWallet=wallet;else{const windowAny=window;if("solana"in windowAny&&typeof windowAny.solana=="object"&&("signIn"in windowAny.solana&&typeof windowAny.solana.signIn=="function"||"signMessage"in windowAny.solana&&typeof windowAny.solana.signMessage=="function"))resolvedWallet=windowAny.solana;else throw new Error("@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.")}else{if(typeof wallet!="object"||!options?.url)throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");resolvedWallet=wallet}const url=new URL((_a=options?.url)!==null&&_a!==void 0?_a:window.location.href);if("signIn"in resolvedWallet&&resolvedWallet.signIn){const output=await resolvedWallet.signIn(Object.assign(Object.assign(Object.assign({issuedAt:new Date().toISOString()},options?.signInWithSolana),{version:"1",domain:url.host,uri:url.href}),statement?{statement}:null));let outputToProcess;if(Array.isArray(output)&&output[0]&&typeof output[0]=="object")outputToProcess=output[0];else if(output&&typeof output=="object"&&"signedMessage"in output&&"signature"in output)outputToProcess=output;else throw new Error("@supabase/auth-js: Wallet method signIn() returned unrecognized value");if("signedMessage"in outputToProcess&&"signature"in outputToProcess&&(typeof outputToProcess.signedMessage=="string"||outputToProcess.signedMessage instanceof Uint8Array)&&outputToProcess.signature instanceof Uint8Array)message=typeof outputToProcess.signedMessage=="string"?outputToProcess.signedMessage:new TextDecoder().decode(outputToProcess.signedMessage),signature=outputToProcess.signature;else throw new Error("@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields")}else{if(!("signMessage"in resolvedWallet)||typeof resolvedWallet.signMessage!="function"||!("publicKey"in resolvedWallet)||typeof resolvedWallet!="object"||!resolvedWallet.publicKey||!("toBase58"in resolvedWallet.publicKey)||typeof resolvedWallet.publicKey.toBase58!="function")throw new Error("@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API");message=[`${url.host} wants you to sign in with your Solana account:`,resolvedWallet.publicKey.toBase58(),...statement?["",statement,""]:[""],"Version: 1",`URI: ${url.href}`,`Issued At: ${(_c=(_b=options?.signInWithSolana)===null||_b===void 0?void 0:_b.issuedAt)!==null&&_c!==void 0?_c:new Date().toISOString()}`,...!((_d=options?.signInWithSolana)===null||_d===void 0)&&_d.notBefore?[`Not Before: ${options.signInWithSolana.notBefore}`]:[],...!((_e=options?.signInWithSolana)===null||_e===void 0)&&_e.expirationTime?[`Expiration Time: ${options.signInWithSolana.expirationTime}`]:[],...!((_f=options?.signInWithSolana)===null||_f===void 0)&&_f.chainId?[`Chain ID: ${options.signInWithSolana.chainId}`]:[],...!((_g=options?.signInWithSolana)===null||_g===void 0)&&_g.nonce?[`Nonce: ${options.signInWithSolana.nonce}`]:[],...!((_h=options?.signInWithSolana)===null||_h===void 0)&&_h.requestId?[`Request ID: ${options.signInWithSolana.requestId}`]:[],...!((_k=(_j=options?.signInWithSolana)===null||_j===void 0?void 0:_j.resources)===null||_k===void 0)&&_k.length?["Resources",...options.signInWithSolana.resources.map(resource=>`- ${resource}`)]:[]].join(`
`);const maybeSignature=await resolvedWallet.signMessage(new TextEncoder().encode(message),"utf8");if(!maybeSignature||!(maybeSignature instanceof Uint8Array))throw new Error("@supabase/auth-js: Wallet signMessage() API returned an recognized value");signature=maybeSignature}}try{const{data,error}=await _request(this.fetch,"POST",`${this.url}/token?grant_type=web3`,{headers:this.headers,body:Object.assign({chain:"solana",message,signature:bytesToBase64URL(signature)},!((_l=credentials.options)===null||_l===void 0)&&_l.captchaToken?{gotrue_meta_security:{captcha_token:(_m=credentials.options)===null||_m===void 0?void 0:_m.captchaToken}}:null),xform:_sessionResponse});if(error)throw error;return!data||!data.session||!data.user?{data:{user:null,session:null},error:new AuthInvalidTokenResponseError}:(data.session&&(await this._saveSession(data.session),await this._notifyAllSubscribers("SIGNED_IN",data.session)),{data:Object.assign({},data),error})}catch(error){if(isAuthError(error))return{data:{user:null,session:null},error};throw error}}async _exchangeCodeForSession(authCode){const storageItem=await getItemAsync(this.storage,`${this.storageKey}-code-verifier`),[codeVerifier,redirectType]=(storageItem??"").split("/");try{const{data,error}=await _request(this.fetch,"POST",`${this.url}/token?grant_type=pkce`,{headers:this.headers,body:{auth_code:authCode,code_verifier:codeVerifier},xform:_sessionResponse});if(await removeItemAsync(this.storage,`${this.storageKey}-code-verifier`),error)throw error;return!data||!data.session||!data.user?{data:{user:null,session:null,redirectType:null},error:new AuthInvalidTokenResponseError}:(data.session&&(await this._saveSession(data.session),await this._notifyAllSubscribers("SIGNED_IN",data.session)),{data:Object.assign(Object.assign({},data),{redirectType:redirectType??null}),error})}catch(error){if(isAuthError(error))return{data:{user:null,session:null,redirectType:null},error};throw error}}async signInWithIdToken(credentials){try{const{options,provider,token,access_token,nonce}=credentials,res=await _request(this.fetch,"POST",`${this.url}/token?grant_type=id_token`,{headers:this.headers,body:{provider,id_token:token,access_token,nonce,gotrue_meta_security:{captcha_token:options?.captchaToken}},xform:_sessionResponse}),{data,error}=res;return error?{data:{user:null,session:null},error}:!data||!data.session||!data.user?{data:{user:null,session:null},error:new AuthInvalidTokenResponseError}:(data.session&&(await this._saveSession(data.session),await this._notifyAllSubscribers("SIGNED_IN",data.session)),{data,error})}catch(error){if(isAuthError(error))return{data:{user:null,session:null},error};throw error}}async signInWithOtp(credentials){var _a,_b,_c,_d,_e;try{if("email"in credentials){const{email,options}=credentials;let codeChallenge=null,codeChallengeMethod=null;this.flowType==="pkce"&&([codeChallenge,codeChallengeMethod]=await getCodeChallengeAndMethod(this.storage,this.storageKey));const{error}=await _request(this.fetch,"POST",`${this.url}/otp`,{headers:this.headers,body:{email,data:(_a=options?.data)!==null&&_a!==void 0?_a:{},create_user:(_b=options?.shouldCreateUser)!==null&&_b!==void 0?_b:!0,gotrue_meta_security:{captcha_token:options?.captchaToken},code_challenge:codeChallenge,code_challenge_method:codeChallengeMethod},redirectTo:options?.emailRedirectTo});return{data:{user:null,session:null},error}}if("phone"in credentials){const{phone,options}=credentials,{data,error}=await _request(this.fetch,"POST",`${this.url}/otp`,{headers:this.headers,body:{phone,data:(_c=options?.data)!==null&&_c!==void 0?_c:{},create_user:(_d=options?.shouldCreateUser)!==null&&_d!==void 0?_d:!0,gotrue_meta_security:{captcha_token:options?.captchaToken},channel:(_e=options?.channel)!==null&&_e!==void 0?_e:"sms"}});return{data:{user:null,session:null,messageId:data?.message_id},error}}throw new AuthInvalidCredentialsError("You must provide either an email or phone number.")}catch(error){if(isAuthError(error))return{data:{user:null,session:null},error};throw error}}async verifyOtp(params){var _a,_b;try{let redirectTo,captchaToken;"options"in params&&(redirectTo=(_a=params.options)===null||_a===void 0?void 0:_a.redirectTo,captchaToken=(_b=params.options)===null||_b===void 0?void 0:_b.captchaToken);const{data,error}=await _request(this.fetch,"POST",`${this.url}/verify`,{headers:this.headers,body:Object.assign(Object.assign({},params),{gotrue_meta_security:{captcha_token:captchaToken}}),redirectTo,xform:_sessionResponse});if(error)throw error;if(!data)throw new Error("An error occurred on token verification.");const session=data.session,user=data.user;return session?.access_token&&(await this._saveSession(session),await this._notifyAllSubscribers(params.type=="recovery"?"PASSWORD_RECOVERY":"SIGNED_IN",session)),{data:{user,session},error:null}}catch(error){if(isAuthError(error))return{data:{user:null,session:null},error};throw error}}async signInWithSSO(params){var _a,_b,_c;try{let codeChallenge=null,codeChallengeMethod=null;return this.flowType==="pkce"&&([codeChallenge,codeChallengeMethod]=await getCodeChallengeAndMethod(this.storage,this.storageKey)),await _request(this.fetch,"POST",`${this.url}/sso`,{body:Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},"providerId"in params?{provider_id:params.providerId}:null),"domain"in params?{domain:params.domain}:null),{redirect_to:(_b=(_a=params.options)===null||_a===void 0?void 0:_a.redirectTo)!==null&&_b!==void 0?_b:void 0}),!((_c=params?.options)===null||_c===void 0)&&_c.captchaToken?{gotrue_meta_security:{captcha_token:params.options.captchaToken}}:null),{skip_http_redirect:!0,code_challenge:codeChallenge,code_challenge_method:codeChallengeMethod}),headers:this.headers,xform:_ssoResponse})}catch(error){if(isAuthError(error))return{data:null,error};throw error}}async reauthenticate(){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._reauthenticate())}async _reauthenticate(){try{return await this._useSession(async result=>{const{data:{session},error:sessionError}=result;if(sessionError)throw sessionError;if(!session)throw new AuthSessionMissingError;const{error}=await _request(this.fetch,"GET",`${this.url}/reauthenticate`,{headers:this.headers,jwt:session.access_token});return{data:{user:null,session:null},error}})}catch(error){if(isAuthError(error))return{data:{user:null,session:null},error};throw error}}async resend(credentials){try{const endpoint=`${this.url}/resend`;if("email"in credentials){const{email,type,options}=credentials,{error}=await _request(this.fetch,"POST",endpoint,{headers:this.headers,body:{email,type,gotrue_meta_security:{captcha_token:options?.captchaToken}},redirectTo:options?.emailRedirectTo});return{data:{user:null,session:null},error}}else if("phone"in credentials){const{phone,type,options}=credentials,{data,error}=await _request(this.fetch,"POST",endpoint,{headers:this.headers,body:{phone,type,gotrue_meta_security:{captcha_token:options?.captchaToken}}});return{data:{user:null,session:null,messageId:data?.message_id},error}}throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a type")}catch(error){if(isAuthError(error))return{data:{user:null,session:null},error};throw error}}async getSession(){return await this.initializePromise,await this._acquireLock(-1,async()=>this._useSession(async result2=>result2))}async _acquireLock(acquireTimeout,fn){this._debug("#_acquireLock","begin",acquireTimeout);try{if(this.lockAcquired){const last=this.pendingInLock.length?this.pendingInLock[this.pendingInLock.length-1]:Promise.resolve(),result=(async()=>(await last,await fn()))();return this.pendingInLock.push((async()=>{try{await result}catch{}})()),result}return await this.lock(`lock:${this.storageKey}`,acquireTimeout,async()=>{this._debug("#_acquireLock","lock acquired for storage key",this.storageKey);try{this.lockAcquired=!0;const result=fn();for(this.pendingInLock.push((async()=>{try{await result}catch{}})()),await result;this.pendingInLock.length;){const waitOn=[...this.pendingInLock];await Promise.all(waitOn),this.pendingInLock.splice(0,waitOn.length)}return await result}finally{this._debug("#_acquireLock","lock released for storage key",this.storageKey),this.lockAcquired=!1}})}finally{this._debug("#_acquireLock","end")}}async _useSession(fn){this._debug("#_useSession","begin");try{const result=await this.__loadSession();return await fn(result)}finally{this._debug("#_useSession","end")}}async __loadSession(){this._debug("#__loadSession()","begin"),this.lockAcquired||this._debug("#__loadSession()","used outside of an acquired lock!",new Error().stack);try{let currentSession=null;const maybeSession=await getItemAsync(this.storage,this.storageKey);if(this._debug("#getSession()","session from storage",maybeSession),maybeSession!==null&&(this._isValidSession(maybeSession)?currentSession=maybeSession:(this._debug("#getSession()","session from storage is not valid"),await this._removeSession())),!currentSession)return{data:{session:null},error:null};const hasExpired=currentSession.expires_at?currentSession.expires_at*1e3-Date.now()<EXPIRY_MARGIN_MS:!1;if(this._debug("#__loadSession()",`session has${hasExpired?"":" not"} expired`,"expires_at",currentSession.expires_at),!hasExpired){if(this.userStorage){const maybeUser=await getItemAsync(this.userStorage,this.storageKey+"-user");maybeUser?.user?currentSession.user=maybeUser.user:currentSession.user=userNotAvailableProxy()}if(this.storage.isServer&&currentSession.user){let suppressWarning=this.suppressGetSessionWarning;currentSession=new Proxy(currentSession,{get:(target,prop,receiver)=>(!suppressWarning&&prop==="user"&&(console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server."),suppressWarning=!0,this.suppressGetSessionWarning=!0),Reflect.get(target,prop,receiver))})}return{data:{session:currentSession},error:null}}const{session,error}=await this._callRefreshToken(currentSession.refresh_token);return error?{data:{session:null},error}:{data:{session},error:null}}finally{this._debug("#__loadSession()","end")}}async getUser(jwt){return jwt?await this._getUser(jwt):(await this.initializePromise,await this._acquireLock(-1,async()=>await this._getUser()))}async _getUser(jwt){try{return jwt?await _request(this.fetch,"GET",`${this.url}/user`,{headers:this.headers,jwt,xform:_userResponse}):await this._useSession(async result=>{var _a,_b,_c;const{data,error}=result;if(error)throw error;return!(!((_a=data.session)===null||_a===void 0)&&_a.access_token)&&!this.hasCustomAuthorizationHeader?{data:{user:null},error:new AuthSessionMissingError}:await _request(this.fetch,"GET",`${this.url}/user`,{headers:this.headers,jwt:(_c=(_b=data.session)===null||_b===void 0?void 0:_b.access_token)!==null&&_c!==void 0?_c:void 0,xform:_userResponse})})}catch(error){if(isAuthError(error))return isAuthSessionMissingError(error)&&(await this._removeSession(),await removeItemAsync(this.storage,`${this.storageKey}-code-verifier`)),{data:{user:null},error};throw error}}async updateUser(attributes,options={}){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._updateUser(attributes,options))}async _updateUser(attributes,options={}){try{return await this._useSession(async result=>{const{data:sessionData,error:sessionError}=result;if(sessionError)throw sessionError;if(!sessionData.session)throw new AuthSessionMissingError;const session=sessionData.session;let codeChallenge=null,codeChallengeMethod=null;this.flowType==="pkce"&&attributes.email!=null&&([codeChallenge,codeChallengeMethod]=await getCodeChallengeAndMethod(this.storage,this.storageKey));const{data,error:userError}=await _request(this.fetch,"PUT",`${this.url}/user`,{headers:this.headers,redirectTo:options?.emailRedirectTo,body:Object.assign(Object.assign({},attributes),{code_challenge:codeChallenge,code_challenge_method:codeChallengeMethod}),jwt:session.access_token,xform:_userResponse});if(userError)throw userError;return session.user=data.user,await this._saveSession(session),await this._notifyAllSubscribers("USER_UPDATED",session),{data:{user:session.user},error:null}})}catch(error){if(isAuthError(error))return{data:{user:null},error};throw error}}async setSession(currentSession){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._setSession(currentSession))}async _setSession(currentSession){try{if(!currentSession.access_token||!currentSession.refresh_token)throw new AuthSessionMissingError;const timeNow=Date.now()/1e3;let expiresAt2=timeNow,hasExpired=!0,session=null;const{payload}=decodeJWT(currentSession.access_token);if(payload.exp&&(expiresAt2=payload.exp,hasExpired=expiresAt2<=timeNow),hasExpired){const{session:refreshedSession,error}=await this._callRefreshToken(currentSession.refresh_token);if(error)return{data:{user:null,session:null},error};if(!refreshedSession)return{data:{user:null,session:null},error:null};session=refreshedSession}else{const{data,error}=await this._getUser(currentSession.access_token);if(error)throw error;session={access_token:currentSession.access_token,refresh_token:currentSession.refresh_token,user:data.user,token_type:"bearer",expires_in:expiresAt2-timeNow,expires_at:expiresAt2},await this._saveSession(session),await this._notifyAllSubscribers("SIGNED_IN",session)}return{data:{user:session.user,session},error:null}}catch(error){if(isAuthError(error))return{data:{session:null,user:null},error};throw error}}async refreshSession(currentSession){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._refreshSession(currentSession))}async _refreshSession(currentSession){try{return await this._useSession(async result=>{var _a;if(!currentSession){const{data,error:error2}=result;if(error2)throw error2;currentSession=(_a=data.session)!==null&&_a!==void 0?_a:void 0}if(!currentSession?.refresh_token)throw new AuthSessionMissingError;const{session,error}=await this._callRefreshToken(currentSession.refresh_token);return error?{data:{user:null,session:null},error}:session?{data:{user:session.user,session},error:null}:{data:{user:null,session:null},error:null}})}catch(error){if(isAuthError(error))return{data:{user:null,session:null},error};throw error}}async _getSessionFromURL(params,callbackUrlType){try{if(!isBrowser())throw new AuthImplicitGrantRedirectError("No browser detected.");if(params.error||params.error_description||params.error_code)throw new AuthImplicitGrantRedirectError(params.error_description||"Error in URL with unspecified error_description",{error:params.error||"unspecified_error",code:params.error_code||"unspecified_code"});switch(callbackUrlType){case"implicit":if(this.flowType==="pkce")throw new AuthPKCEGrantCodeExchangeError("Not a valid PKCE flow url.");break;case"pkce":if(this.flowType==="implicit")throw new AuthImplicitGrantRedirectError("Not a valid implicit grant flow url.");break;default:}if(callbackUrlType==="pkce"){if(this._debug("#_initialize()","begin","is PKCE flow",!0),!params.code)throw new AuthPKCEGrantCodeExchangeError("No code detected.");const{data:data2,error:error2}=await this._exchangeCodeForSession(params.code);if(error2)throw error2;const url=new URL(window.location.href);return url.searchParams.delete("code"),window.history.replaceState(window.history.state,"",url.toString()),{data:{session:data2.session,redirectType:null},error:null}}const{provider_token,provider_refresh_token,access_token,refresh_token,expires_in,expires_at,token_type}=params;if(!access_token||!expires_in||!refresh_token||!token_type)throw new AuthImplicitGrantRedirectError("No session defined in URL");const timeNow=Math.round(Date.now()/1e3),expiresIn=parseInt(expires_in);let expiresAt2=timeNow+expiresIn;expires_at&&(expiresAt2=parseInt(expires_at));const actuallyExpiresIn=expiresAt2-timeNow;actuallyExpiresIn*1e3<=AUTO_REFRESH_TICK_DURATION_MS&&console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${actuallyExpiresIn}s, should have been closer to ${expiresIn}s`);const issuedAt=expiresAt2-expiresIn;timeNow-issuedAt>=120?console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale",issuedAt,expiresAt2,timeNow):timeNow-issuedAt<0&&console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew",issuedAt,expiresAt2,timeNow);const{data,error}=await this._getUser(access_token);if(error)throw error;const session={provider_token,provider_refresh_token,access_token,expires_in:expiresIn,expires_at:expiresAt2,refresh_token,token_type,user:data.user};return window.location.hash="",this._debug("#_getSessionFromURL()","clearing window.location.hash"),{data:{session,redirectType:params.type},error:null}}catch(error){if(isAuthError(error))return{data:{session:null,redirectType:null},error};throw error}}_isImplicitGrantCallback(params){return!!(params.access_token||params.error_description)}async _isPKCECallback(params){const currentStorageContent=await getItemAsync(this.storage,`${this.storageKey}-code-verifier`);return!!(params.code&&currentStorageContent)}async signOut(options={scope:"global"}){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._signOut(options))}async _signOut({scope}={scope:"global"}){return await this._useSession(async result=>{var _a;const{data,error:sessionError}=result;if(sessionError)return{error:sessionError};const accessToken=(_a=data.session)===null||_a===void 0?void 0:_a.access_token;if(accessToken){const{error}=await this.admin.signOut(accessToken,scope);if(error&&!(isAuthApiError(error)&&(error.status===404||error.status===401||error.status===403)))return{error}}return scope!=="others"&&(await this._removeSession(),await removeItemAsync(this.storage,`${this.storageKey}-code-verifier`)),{error:null}})}onAuthStateChange(callback){const id=uuid(),subscription={id,callback,unsubscribe:()=>{this._debug("#unsubscribe()","state change callback with id removed",id),this.stateChangeEmitters.delete(id)}};return this._debug("#onAuthStateChange()","registered callback with id",id),this.stateChangeEmitters.set(id,subscription),(async()=>(await this.initializePromise,await this._acquireLock(-1,async()=>{this._emitInitialSession(id)})))(),{data:{subscription}}}async _emitInitialSession(id){return await this._useSession(async result=>{var _a,_b;try{const{data:{session},error}=result;if(error)throw error;await((_a=this.stateChangeEmitters.get(id))===null||_a===void 0?void 0:_a.callback("INITIAL_SESSION",session)),this._debug("INITIAL_SESSION","callback id",id,"session",session)}catch(err){await((_b=this.stateChangeEmitters.get(id))===null||_b===void 0?void 0:_b.callback("INITIAL_SESSION",null)),this._debug("INITIAL_SESSION","callback id",id,"error",err),console.error(err)}})}async resetPasswordForEmail(email,options={}){let codeChallenge=null,codeChallengeMethod=null;this.flowType==="pkce"&&([codeChallenge,codeChallengeMethod]=await getCodeChallengeAndMethod(this.storage,this.storageKey,!0));try{return await _request(this.fetch,"POST",`${this.url}/recover`,{body:{email,code_challenge:codeChallenge,code_challenge_method:codeChallengeMethod,gotrue_meta_security:{captcha_token:options.captchaToken}},headers:this.headers,redirectTo:options.redirectTo})}catch(error){if(isAuthError(error))return{data:null,error};throw error}}async getUserIdentities(){var _a;try{const{data,error}=await this.getUser();if(error)throw error;return{data:{identities:(_a=data.user.identities)!==null&&_a!==void 0?_a:[]},error:null}}catch(error){if(isAuthError(error))return{data:null,error};throw error}}async linkIdentity(credentials){var _a;try{const{data,error}=await this._useSession(async result=>{var _a2,_b,_c,_d,_e;const{data:data2,error:error2}=result;if(error2)throw error2;const url=await this._getUrlForProvider(`${this.url}/user/identities/authorize`,credentials.provider,{redirectTo:(_a2=credentials.options)===null||_a2===void 0?void 0:_a2.redirectTo,scopes:(_b=credentials.options)===null||_b===void 0?void 0:_b.scopes,queryParams:(_c=credentials.options)===null||_c===void 0?void 0:_c.queryParams,skipBrowserRedirect:!0});return await _request(this.fetch,"GET",url,{headers:this.headers,jwt:(_e=(_d=data2.session)===null||_d===void 0?void 0:_d.access_token)!==null&&_e!==void 0?_e:void 0})});if(error)throw error;return isBrowser()&&!(!((_a=credentials.options)===null||_a===void 0)&&_a.skipBrowserRedirect)&&window.location.assign(data?.url),{data:{provider:credentials.provider,url:data?.url},error:null}}catch(error){if(isAuthError(error))return{data:{provider:credentials.provider,url:null},error};throw error}}async unlinkIdentity(identity){try{return await this._useSession(async result=>{var _a,_b;const{data,error}=result;if(error)throw error;return await _request(this.fetch,"DELETE",`${this.url}/user/identities/${identity.identity_id}`,{headers:this.headers,jwt:(_b=(_a=data.session)===null||_a===void 0?void 0:_a.access_token)!==null&&_b!==void 0?_b:void 0})})}catch(error){if(isAuthError(error))return{data:null,error};throw error}}async _refreshAccessToken(refreshToken){const debugName=`#_refreshAccessToken(${refreshToken.substring(0,5)}...)`;this._debug(debugName,"begin");try{const startedAt=Date.now();return await retryable(async attempt=>(attempt>0&&await sleep(200*Math.pow(2,attempt-1)),this._debug(debugName,"refreshing attempt",attempt),await _request(this.fetch,"POST",`${this.url}/token?grant_type=refresh_token`,{body:{refresh_token:refreshToken},headers:this.headers,xform:_sessionResponse})),(attempt,error)=>{const nextBackOffInterval=200*Math.pow(2,attempt);return error&&isAuthRetryableFetchError(error)&&Date.now()+nextBackOffInterval-startedAt<AUTO_REFRESH_TICK_DURATION_MS})}catch(error){if(this._debug(debugName,"error",error),isAuthError(error))return{data:{session:null,user:null},error};throw error}finally{this._debug(debugName,"end")}}_isValidSession(maybeSession){return typeof maybeSession=="object"&&maybeSession!==null&&"access_token"in maybeSession&&"refresh_token"in maybeSession&&"expires_at"in maybeSession}async _handleProviderSignIn(provider,options){const url=await this._getUrlForProvider(`${this.url}/authorize`,provider,{redirectTo:options.redirectTo,scopes:options.scopes,queryParams:options.queryParams});return this._debug("#_handleProviderSignIn()","provider",provider,"options",options,"url",url),isBrowser()&&!options.skipBrowserRedirect&&window.location.assign(url),{data:{provider,url},error:null}}async _recoverAndRefresh(){var _a,_b;const debugName="#_recoverAndRefresh()";this._debug(debugName,"begin");try{const currentSession=await getItemAsync(this.storage,this.storageKey);if(currentSession&&this.userStorage){let maybeUser=await getItemAsync(this.userStorage,this.storageKey+"-user");!this.storage.isServer&&Object.is(this.storage,this.userStorage)&&!maybeUser&&(maybeUser={user:currentSession.user},await setItemAsync(this.userStorage,this.storageKey+"-user",maybeUser)),currentSession.user=(_a=maybeUser?.user)!==null&&_a!==void 0?_a:userNotAvailableProxy()}else if(currentSession&&!currentSession.user&&!currentSession.user){const separateUser=await getItemAsync(this.storage,this.storageKey+"-user");separateUser&&separateUser?.user?(currentSession.user=separateUser.user,await removeItemAsync(this.storage,this.storageKey+"-user"),await setItemAsync(this.storage,this.storageKey,currentSession)):currentSession.user=userNotAvailableProxy()}if(this._debug(debugName,"session from storage",currentSession),!this._isValidSession(currentSession)){this._debug(debugName,"session is not valid"),currentSession!==null&&await this._removeSession();return}const expiresWithMargin=((_b=currentSession.expires_at)!==null&&_b!==void 0?_b:1/0)*1e3-Date.now()<EXPIRY_MARGIN_MS;if(this._debug(debugName,`session has${expiresWithMargin?"":" not"} expired with margin of ${EXPIRY_MARGIN_MS}s`),expiresWithMargin){if(this.autoRefreshToken&&currentSession.refresh_token){const{error}=await this._callRefreshToken(currentSession.refresh_token);error&&(console.error(error),isAuthRetryableFetchError(error)||(this._debug(debugName,"refresh failed with a non-retryable error, removing the session",error),await this._removeSession()))}}else if(currentSession.user&&currentSession.user.__isUserNotAvailableProxy===!0)try{const{data,error:userError}=await this._getUser(currentSession.access_token);!userError&&data?.user?(currentSession.user=data.user,await this._saveSession(currentSession),await this._notifyAllSubscribers("SIGNED_IN",currentSession)):this._debug(debugName,"could not get user data, skipping SIGNED_IN notification")}catch(getUserError){console.error("Error getting user data:",getUserError),this._debug(debugName,"error getting user data, skipping SIGNED_IN notification",getUserError)}else await this._notifyAllSubscribers("SIGNED_IN",currentSession)}catch(err){this._debug(debugName,"error",err),console.error(err);return}finally{this._debug(debugName,"end")}}async _callRefreshToken(refreshToken){var _a,_b;if(!refreshToken)throw new AuthSessionMissingError;if(this.refreshingDeferred)return this.refreshingDeferred.promise;const debugName=`#_callRefreshToken(${refreshToken.substring(0,5)}...)`;this._debug(debugName,"begin");try{this.refreshingDeferred=new Deferred;const{data,error}=await this._refreshAccessToken(refreshToken);if(error)throw error;if(!data.session)throw new AuthSessionMissingError;await this._saveSession(data.session),await this._notifyAllSubscribers("TOKEN_REFRESHED",data.session);const result={session:data.session,error:null};return this.refreshingDeferred.resolve(result),result}catch(error){if(this._debug(debugName,"error",error),isAuthError(error)){const result={session:null,error};return isAuthRetryableFetchError(error)||await this._removeSession(),(_a=this.refreshingDeferred)===null||_a===void 0||_a.resolve(result),result}throw(_b=this.refreshingDeferred)===null||_b===void 0||_b.reject(error),error}finally{this.refreshingDeferred=null,this._debug(debugName,"end")}}async _notifyAllSubscribers(event,session,broadcast=!0){const debugName=`#_notifyAllSubscribers(${event})`;this._debug(debugName,"begin",session,`broadcast = ${broadcast}`);try{this.broadcastChannel&&broadcast&&this.broadcastChannel.postMessage({event,session});const errors=[],promises=Array.from(this.stateChangeEmitters.values()).map(async x=>{try{await x.callback(event,session)}catch(e){errors.push(e)}});if(await Promise.all(promises),errors.length>0){for(let i=0;i<errors.length;i+=1)console.error(errors[i]);throw errors[0]}}finally{this._debug(debugName,"end")}}async _saveSession(session){this._debug("#_saveSession()",session),this.suppressGetSessionWarning=!0;const sessionToProcess=Object.assign({},session),userIsProxy=sessionToProcess.user&&sessionToProcess.user.__isUserNotAvailableProxy===!0;if(this.userStorage){!userIsProxy&&sessionToProcess.user&&await setItemAsync(this.userStorage,this.storageKey+"-user",{user:sessionToProcess.user});const mainSessionData=Object.assign({},sessionToProcess);delete mainSessionData.user;const clonedMainSessionData=deepClone(mainSessionData);await setItemAsync(this.storage,this.storageKey,clonedMainSessionData)}else{const clonedSession=deepClone(sessionToProcess);await setItemAsync(this.storage,this.storageKey,clonedSession)}}async _removeSession(){this._debug("#_removeSession()"),await removeItemAsync(this.storage,this.storageKey),await removeItemAsync(this.storage,this.storageKey+"-code-verifier"),await removeItemAsync(this.storage,this.storageKey+"-user"),this.userStorage&&await removeItemAsync(this.userStorage,this.storageKey+"-user"),await this._notifyAllSubscribers("SIGNED_OUT",null)}_removeVisibilityChangedCallback(){this._debug("#_removeVisibilityChangedCallback()");const callback=this.visibilityChangedCallback;this.visibilityChangedCallback=null;try{callback&&isBrowser()&&window?.removeEventListener&&window.removeEventListener("visibilitychange",callback)}catch(e){console.error("removing visibilitychange callback failed",e)}}async _startAutoRefresh(){await this._stopAutoRefresh(),this._debug("#_startAutoRefresh()");const ticker=setInterval(()=>this._autoRefreshTokenTick(),AUTO_REFRESH_TICK_DURATION_MS);this.autoRefreshTicker=ticker,ticker&&typeof ticker=="object"&&typeof ticker.unref=="function"?ticker.unref():typeof Deno<"u"&&typeof Deno.unrefTimer=="function"&&Deno.unrefTimer(ticker),setTimeout(async()=>{await this.initializePromise,await this._autoRefreshTokenTick()},0)}async _stopAutoRefresh(){this._debug("#_stopAutoRefresh()");const ticker=this.autoRefreshTicker;this.autoRefreshTicker=null,ticker&&clearInterval(ticker)}async startAutoRefresh(){this._removeVisibilityChangedCallback(),await this._startAutoRefresh()}async stopAutoRefresh(){this._removeVisibilityChangedCallback(),await this._stopAutoRefresh()}async _autoRefreshTokenTick(){this._debug("#_autoRefreshTokenTick()","begin");try{await this._acquireLock(0,async()=>{try{const now=Date.now();try{return await this._useSession(async result=>{const{data:{session}}=result;if(!session||!session.refresh_token||!session.expires_at){this._debug("#_autoRefreshTokenTick()","no session");return}const expiresInTicks=Math.floor((session.expires_at*1e3-now)/AUTO_REFRESH_TICK_DURATION_MS);this._debug("#_autoRefreshTokenTick()",`access token expires in ${expiresInTicks} ticks, a tick lasts ${AUTO_REFRESH_TICK_DURATION_MS}ms, refresh threshold is ${AUTO_REFRESH_TICK_THRESHOLD} ticks`),expiresInTicks<=AUTO_REFRESH_TICK_THRESHOLD&&await this._callRefreshToken(session.refresh_token)})}catch(e){console.error("Auto refresh tick failed with error. This is likely a transient error.",e)}}finally{this._debug("#_autoRefreshTokenTick()","end")}})}catch(e){if(e.isAcquireTimeout||e instanceof LockAcquireTimeoutError)this._debug("auto refresh token tick lock not available");else throw e}}async _handleVisibilityChange(){if(this._debug("#_handleVisibilityChange()"),!isBrowser()||!window?.addEventListener)return this.autoRefreshToken&&this.startAutoRefresh(),!1;try{this.visibilityChangedCallback=async()=>await this._onVisibilityChanged(!1),window?.addEventListener("visibilitychange",this.visibilityChangedCallback),await this._onVisibilityChanged(!0)}catch(error){console.error("_handleVisibilityChange",error)}}async _onVisibilityChanged(calledFromInitialize){const methodName=`#_onVisibilityChanged(${calledFromInitialize})`;this._debug(methodName,"visibilityState",document.visibilityState),document.visibilityState==="visible"?(this.autoRefreshToken&&this._startAutoRefresh(),calledFromInitialize||(await this.initializePromise,await this._acquireLock(-1,async()=>{if(document.visibilityState!=="visible"){this._debug(methodName,"acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting");return}await this._recoverAndRefresh()}))):document.visibilityState==="hidden"&&this.autoRefreshToken&&this._stopAutoRefresh()}async _getUrlForProvider(url,provider,options){const urlParams=[`provider=${encodeURIComponent(provider)}`];if(options?.redirectTo&&urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`),options?.scopes&&urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`),this.flowType==="pkce"){const[codeChallenge,codeChallengeMethod]=await getCodeChallengeAndMethod(this.storage,this.storageKey),flowParams=new URLSearchParams({code_challenge:`${encodeURIComponent(codeChallenge)}`,code_challenge_method:`${encodeURIComponent(codeChallengeMethod)}`});urlParams.push(flowParams.toString())}if(options?.queryParams){const query=new URLSearchParams(options.queryParams);urlParams.push(query.toString())}return options?.skipBrowserRedirect&&urlParams.push(`skip_http_redirect=${options.skipBrowserRedirect}`),`${url}?${urlParams.join("&")}`}async _unenroll(params){try{return await this._useSession(async result=>{var _a;const{data:sessionData,error:sessionError}=result;return sessionError?{data:null,error:sessionError}:await _request(this.fetch,"DELETE",`${this.url}/factors/${params.factorId}`,{headers:this.headers,jwt:(_a=sessionData?.session)===null||_a===void 0?void 0:_a.access_token})})}catch(error){if(isAuthError(error))return{data:null,error};throw error}}async _enroll(params){try{return await this._useSession(async result=>{var _a,_b;const{data:sessionData,error:sessionError}=result;if(sessionError)return{data:null,error:sessionError};const body=Object.assign({friendly_name:params.friendlyName,factor_type:params.factorType},params.factorType==="phone"?{phone:params.phone}:{issuer:params.issuer}),{data,error}=await _request(this.fetch,"POST",`${this.url}/factors`,{body,headers:this.headers,jwt:(_a=sessionData?.session)===null||_a===void 0?void 0:_a.access_token});return error?{data:null,error}:(params.factorType==="totp"&&(!((_b=data?.totp)===null||_b===void 0)&&_b.qr_code)&&(data.totp.qr_code=`data:image/svg+xml;utf-8,${data.totp.qr_code}`),{data,error:null})})}catch(error){if(isAuthError(error))return{data:null,error};throw error}}async _verify(params){return this._acquireLock(-1,async()=>{try{return await this._useSession(async result=>{var _a;const{data:sessionData,error:sessionError}=result;if(sessionError)return{data:null,error:sessionError};const{data,error}=await _request(this.fetch,"POST",`${this.url}/factors/${params.factorId}/verify`,{body:{code:params.code,challenge_id:params.challengeId},headers:this.headers,jwt:(_a=sessionData?.session)===null||_a===void 0?void 0:_a.access_token});return error?{data:null,error}:(await this._saveSession(Object.assign({expires_at:Math.round(Date.now()/1e3)+data.expires_in},data)),await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED",data),{data,error})})}catch(error){if(isAuthError(error))return{data:null,error};throw error}})}async _challenge(params){return this._acquireLock(-1,async()=>{try{return await this._useSession(async result=>{var _a;const{data:sessionData,error:sessionError}=result;return sessionError?{data:null,error:sessionError}:await _request(this.fetch,"POST",`${this.url}/factors/${params.factorId}/challenge`,{body:{channel:params.channel},headers:this.headers,jwt:(_a=sessionData?.session)===null||_a===void 0?void 0:_a.access_token})})}catch(error){if(isAuthError(error))return{data:null,error};throw error}})}async _challengeAndVerify(params){const{data:challengeData,error:challengeError}=await this._challenge({factorId:params.factorId});return challengeError?{data:null,error:challengeError}:await this._verify({factorId:params.factorId,challengeId:challengeData.id,code:params.code})}async _listFactors(){const{data:{user},error:userError}=await this.getUser();if(userError)return{data:null,error:userError};const factors=user?.factors||[],totp=factors.filter(factor=>factor.factor_type==="totp"&&factor.status==="verified"),phone=factors.filter(factor=>factor.factor_type==="phone"&&factor.status==="verified");return{data:{all:factors,totp,phone},error:null}}async _getAuthenticatorAssuranceLevel(){return this._acquireLock(-1,async()=>await this._useSession(async result=>{var _a,_b;const{data:{session},error:sessionError}=result;if(sessionError)return{data:null,error:sessionError};if(!session)return{data:{currentLevel:null,nextLevel:null,currentAuthenticationMethods:[]},error:null};const{payload}=decodeJWT(session.access_token);let currentLevel=null;payload.aal&&(currentLevel=payload.aal);let nextLevel=currentLevel;((_b=(_a=session.user.factors)===null||_a===void 0?void 0:_a.filter(factor=>factor.status==="verified"))!==null&&_b!==void 0?_b:[]).length>0&&(nextLevel="aal2");const currentAuthenticationMethods=payload.amr||[];return{data:{currentLevel,nextLevel,currentAuthenticationMethods},error:null}}))}async fetchJwk(kid,jwks={keys:[]}){let jwk=jwks.keys.find(key=>key.kid===kid);if(jwk)return jwk;const now=Date.now();if(jwk=this.jwks.keys.find(key=>key.kid===kid),jwk&&this.jwks_cached_at+JWKS_TTL>now)return jwk;const{data,error}=await _request(this.fetch,"GET",`${this.url}/.well-known/jwks.json`,{headers:this.headers});if(error)throw error;return!data.keys||data.keys.length===0||(this.jwks=data,this.jwks_cached_at=now,jwk=data.keys.find(key=>key.kid===kid),!jwk)?null:jwk}async getClaims(jwt,options={}){try{let token=jwt;if(!token){const{data,error}=await this.getSession();if(error||!data.session)return{data:null,error};token=data.session.access_token}const{header,payload,signature,raw:{header:rawHeader,payload:rawPayload}}=decodeJWT(token);options?.allowExpired||validateExp(payload.exp);const signingKey=!header.alg||header.alg.startsWith("HS")||!header.kid||!("crypto"in globalThis&&"subtle"in globalThis.crypto)?null:await this.fetchJwk(header.kid,options?.keys?{keys:options.keys}:options?.jwks);if(!signingKey){const{error}=await this.getUser(token);if(error)throw error;return{data:{claims:payload,header,signature},error:null}}const algorithm=getAlgorithm(header.alg),publicKey=await crypto.subtle.importKey("jwk",signingKey,algorithm,!0,["verify"]);if(!await crypto.subtle.verify(algorithm,publicKey,signature,stringToUint8Array(`${rawHeader}.${rawPayload}`)))throw new AuthInvalidJwtError("Invalid JWT signature");return{data:{claims:payload,header,signature},error:null}}catch(error){if(isAuthError(error))return{data:null,error};throw error}}}GoTrueClient.nextInstanceID=0;const AuthClient=GoTrueClient;class SupabaseAuthClient extends AuthClient{constructor(options){super(options)}}var __awaiter=function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator.throw(value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,[])).next())})};class SupabaseClient{constructor(supabaseUrl,supabaseKey,options){var _a,_b,_c;if(this.supabaseUrl=supabaseUrl,this.supabaseKey=supabaseKey,!supabaseUrl)throw new Error("supabaseUrl is required.");if(!supabaseKey)throw new Error("supabaseKey is required.");const _supabaseUrl=ensureTrailingSlash(supabaseUrl),baseUrl=new URL(_supabaseUrl);this.realtimeUrl=new URL("realtime/v1",baseUrl),this.realtimeUrl.protocol=this.realtimeUrl.protocol.replace("http","ws"),this.authUrl=new URL("auth/v1",baseUrl),this.storageUrl=new URL("storage/v1",baseUrl),this.functionsUrl=new URL("functions/v1",baseUrl);const defaultStorageKey=`sb-${baseUrl.hostname.split(".")[0]}-auth-token`,DEFAULTS={db:DEFAULT_DB_OPTIONS,realtime:DEFAULT_REALTIME_OPTIONS,auth:Object.assign(Object.assign({},DEFAULT_AUTH_OPTIONS),{storageKey:defaultStorageKey}),global:DEFAULT_GLOBAL_OPTIONS},settings=applySettingDefaults(options??{},DEFAULTS);this.storageKey=(_a=settings.auth.storageKey)!==null&&_a!==void 0?_a:"",this.headers=(_b=settings.global.headers)!==null&&_b!==void 0?_b:{},settings.accessToken?(this.accessToken=settings.accessToken,this.auth=new Proxy({},{get:(_,prop)=>{throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(prop)} is not possible`)}})):this.auth=this._initSupabaseAuthClient((_c=settings.auth)!==null&&_c!==void 0?_c:{},this.headers,settings.global.fetch),this.fetch=fetchWithAuth(supabaseKey,this._getAccessToken.bind(this),settings.global.fetch),this.realtime=this._initRealtimeClient(Object.assign({headers:this.headers,accessToken:this._getAccessToken.bind(this)},settings.realtime)),this.rest=new PostgrestClient2(new URL("rest/v1",baseUrl).href,{headers:this.headers,schema:settings.db.schema,fetch:this.fetch}),settings.accessToken||this._listenForAuthEvents()}get functions(){return new FunctionsClient(this.functionsUrl.href,{headers:this.headers,customFetch:this.fetch})}get storage(){return new StorageClient(this.storageUrl.href,this.headers,this.fetch)}from(relation){return this.rest.from(relation)}schema(schema){return this.rest.schema(schema)}rpc(fn,args={},options={}){return this.rest.rpc(fn,args,options)}channel(name,opts={config:{}}){return this.realtime.channel(name,opts)}getChannels(){return this.realtime.getChannels()}removeChannel(channel){return this.realtime.removeChannel(channel)}removeAllChannels(){return this.realtime.removeAllChannels()}_getAccessToken(){var _a,_b;return __awaiter(this,void 0,void 0,function*(){if(this.accessToken)return yield this.accessToken();const{data}=yield this.auth.getSession();return(_b=(_a=data.session)===null||_a===void 0?void 0:_a.access_token)!==null&&_b!==void 0?_b:null})}_initSupabaseAuthClient({autoRefreshToken,persistSession,detectSessionInUrl,storage,storageKey,flowType,lock,debug},headers,fetch2){const authHeaders={Authorization:`Bearer ${this.supabaseKey}`,apikey:`${this.supabaseKey}`};return new SupabaseAuthClient({url:this.authUrl.href,headers:Object.assign(Object.assign({},authHeaders),headers),storageKey,autoRefreshToken,persistSession,detectSessionInUrl,storage,flowType,lock,debug,fetch:fetch2,hasCustomAuthorizationHeader:"Authorization"in this.headers})}_initRealtimeClient(options){return new RealtimeClient(this.realtimeUrl.href,Object.assign(Object.assign({},options),{params:Object.assign({apikey:this.supabaseKey},options?.params)}))}_listenForAuthEvents(){return this.auth.onAuthStateChange((event,session)=>{this._handleTokenChanged(event,"CLIENT",session?.access_token)})}_handleTokenChanged(event,source,token){(event==="TOKEN_REFRESHED"||event==="SIGNED_IN")&&this.changedAccessToken!==token?this.changedAccessToken=token:event==="SIGNED_OUT"&&(this.realtime.setAuth(),source=="STORAGE"&&this.auth.signOut(),this.changedAccessToken=void 0)}}const createClient=(supabaseUrl,supabaseKey,options)=>new SupabaseClient(supabaseUrl,supabaseKey,options);function shouldShowDeprecationWarning(){if(typeof window<"u"||typeof process>"u"||process.version===void 0||process.version===null)return!1;const versionMatch=process.version.match(/^v(\d+)\./);return versionMatch?parseInt(versionMatch[1],10)<=18:!1}shouldShowDeprecationWarning()&&console.warn("  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217");export{__vitePreload as _,createClient as c};
